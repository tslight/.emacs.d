#+TITLE: EMACS CONFIGURATION
#+AUTHOR: Toby Slight
#+PROPERTY: header-args :cache yes
#+PROPERTY: header-args+ :mkdirp yes
#+PROPERTY: header-args+ :results silent
#+PROPERTY: header-args+ :tangle ~/.emacs.d/init.el
#+PROPERTY: header-args+ :tangle-mode (identity #o644)
#+OPTIONS: toc:t

A fairly standard [[https://en.wikipedia.org/wiki/Literate_programming][literate]] Emacs configuration using [[https://orgmode.org/][Org mode]].

Quickest way to get setup is to back up your current config:

#+begin_src shell :tangle no
  mv ~/.emacs.d{,.bak}
#+end_src

Then clone this repo to replace it:

#+begin_src shell :tangle no
  git clone https://gitlab.com/tspub/lisp/emacs ~/.emacs.d
#+end_src

Alternatively you can clone to a different location and ~org-babel-tangle~ this
file with ~C-c C-v t~ whilst visiting this file.

That will copy all the source code blocks in this file and overwrite whatever
you have in your ~$HOME/.emacs.d/early-init.el~ and ~$HOME/.emacs.d/init.el~
files, so make sure you've backed up anything you don't want to lose!

* Contents:TOC_5_gh:
- [[#early-init][Early Init]]
- [[#avoid-garbage-collection-at-startup][Avoid garbage collection at startup]]
- [[#unset-file-name-handler-alist-temporarily][Unset file-name-handler-alist temporarily]]
- [[#ensure-init-files-are-byte-compiled][Ensure init files are byte compiled]]
- [[#emacs-configuration-with-no-packages][Emacs configuration with no packages]]
  - [[#aligning-symbols][Aligning symbols]]
  - [[#ansi-color][ANSI color]]
  - [[#buffers][Buffers]]
    - [[#fill-buffer][Fill Buffer]]
    - [[#indent-buffer][Indent Buffer]]
    - [[#kill-this-buffer][Kill this buffer]]
    - [[#last-buffer][Last buffer]]
    - [[#nuke-buffers][Nuke buffers]]
    - [[#save-buffers-silently][Save buffers silently]]
    - [[#search-all-buffers][Search all buffers]]
    - [[#toggle-buffer][Toggle buffer]]
    - [[#toggle-messages-buffer][Toggle messages buffer]]
    - [[#toggle-scratch-buffer][Toggle scratch buffer]]
    - [[#toggle-maximize-buffer][Toggle maximize buffer]]
    - [[#buffer-keybindings][Buffer keybindings]]
    - [[#uniquify][Uniquify]]
  - [[#change-numbers][Change numbers]]
  - [[#change-pairs][Change pairs]]
  - [[#file-encoding-stuff][File encoding stuff]]
  - [[#complilation-related][Complilation related]]
  - [[#dabbrev][Dabbrev]]
  - [[#dired][Dired]]
  - [[#ediff][Ediff]]
  - [[#editing][Editing]]
    - [[#delete-inside-delimiters][Delete inside delimiters]]
    - [[#generate-a-numbered-list][Generate a numbered list]]
    - [[#insert-a-timestamp-at-the-point][Insert a timestamp at the point]]
    - [[#open-a-line-above-the-current-line][Open a line above the current line]]
    - [[#open-a-line-below-the-current-line][Open a line below the current line]]
    - [[#sort-lines-in-an-case-insensitive-manner][Sort lines in an case insensitive manner]]
    - [[#surround-stuff][Surround stuff]]
    - [[#underline-text][Underline text]]
    - [[#untabify-a-buffer-fuck-spaces][Untabify a buffer (fuck spaces!)]]
    - [[#xml-pretty-print][XML pretty print]]
    - [[#yank-pop-forwards][Yank pop forwards]]
    - [[#custom-editing-function-bindings][Custom editing function bindings]]
    - [[#editing-related-keyboard-built-in-keybindings][Editing related keyboard built-in keybindings]]
    - [[#dwim-replacements-for-changing-case][DWIM replacements for changing case]]
  - [[#erc][ERC]]
  - [[#eshell][Eshell]]
  - [[#files][Files]]
  - [[#gnus][Gnus]]
  - [[#hooks][Hooks]]
  - [[#icomplete][Icomplete]]
  - [[#imenu][Imenu]]
  - [[#isearch][Isearch]]
  - [[#keys][Keys]]
  - [[#marks][Marks]]
  - [[#minibuffer][Minibuffer]]
  - [[#misc][Misc]]
  - [[#org][Org]]
  - [[#recentf][Recentf]]
  - [[#registers][Registers]]
  - [[#removes][Removes]]
  - [[#settings][Settings]]
  - [[#shell-script][Shell script]]
  - [[#smart][Smart]]
  - [[#style][Style]]
  - [[#term][Term]]
  - [[#theme][Theme]]
  - [[#whitespace][Whitespace]]
  - [[#windows][Windows]]
- [[#third-party-package-configuration][Third party package configuration]]
  - [[#setup-packageel-and-use-package][Setup package.el and use-package]]
  - [[#ansible][Ansible]]
  - [[#async][Async]]
  - [[#blacken][Blacken]]
  - [[#default-text-scaling][Default text scaling]]
  - [[#diminish][Diminish]]
  - [[#docker][Docker]]
  - [[#exec-path-from-shell][Exec path from shell]]
  - [[#flycheck][Flycheck]]
  - [[#git-timemachine][Git Timemachine]]
  - [[#gitlab-ci][Gitlab CI]]
  - [[#go-mode][Go mode]]
  - [[#hungry-delete][Hungry delete]]
  - [[#ibuffer-vc][Ibuffer VC]]
  - [[#js2-mode][JS2 mode]]
  - [[#json][JSON]]
  - [[#lazygit][Lazygit]]
  - [[#magit][Magit]]
  - [[#markdown][Markdown]]
  - [[#node-js][Node JS]]
  - [[#org-1][Org]]
    - [[#org-bullets][Org Bullets]]
    - [[#htmlize][HTMLize]]
    - [[#toc-org][Toc Org]]
    - [[#pdf-tools][PDF Tools]]
  - [[#powershell][Powershell]]
  - [[#powerline][Powerline]]
  - [[#projectile][Projectile]]
  - [[#restclient][RESTClient]]
  - [[#systemd][systemd]]
  - [[#terraform][Terraform]]
  - [[#web-mode][Web Mode]]
  - [[#writeable-grep][Writeable Grep]]
  - [[#which-key][Which Key]]
  - [[#yaml][YAML]]
  - [[#yasnippet][Yasnippet]]
    - [[#snippets][Snippets]]
    - [[#classic-snippets][Classic snippets]]
    - [[#custom-yasnippet-snippets][Custom Yasnippet snippets]]
      - [[#emacs-lisp-snippets][Emacs Lisp snippets]]
        - [[#standard-elisp-boilerplate][Standard elisp boilerplate]]
        - [[#package-elisp-boilerplate][Package elisp boilerplate]]
- [[#restore-garbage-collection][Restore garbage collection]]
- [[#restore-original-file-name-handler-alist][Restore original file-name-handler-alist]]

* Early Init

From ~/etc/NEWS~

#+begin_quote
Emacs can now be configured using an early init file. The file is called
early-init.el, in user-emacs-directory. It is loaded very early in the startup
process: before graphical elements such as the tool bar are initialized, and
before the package manager is initialized. The primary purpose is to allow
customizing how the package system is initialized given that initialization now
happens before loading the regular init file (see below).

We recommend against putting any customizations in this file that don't need to
be set up before initializing installed add-on packages, because the early init
file is read too early into the startup process, and some important parts of
the Emacs session, such as 'window-system' and other GUI features, are not yet
set up, which could make some customization fail to work.
#+end_quote

#+begin_src emacs-lisp :tangle ~/.emacs.d/early-init.el
  (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'tooltip-mode) (tooltip-mode -1))

  (setq frame-resize-pixelwise t) ;; jwm resize fix

  ;; This must be true otherwise use-package won't load!
  (setq package-enable-at-startup t)
  ;; Allow loading from the package cache.
  (setq package-quickstart t)
  ;; Don't write (package-initialize) to my init file!
  (setq package--init-file-ensured t)

  (setq package-archives
        '(("melpa" . "https://melpa.org/packages/")
          ("gnu" . "https://elpa.gnu.org/packages/")))
#+end_src

* Avoid garbage collection at startup

The GC can easily double startup time, so we suppress it at startup by turning
up gc-cons-threshold (and perhaps gc-cons-percentage) temporarily:

#+begin_src emacs-lisp
  (setq gc-cons-threshold most-positive-fixnum ; 2^61 bytes
        gc-cons-percentage 0.6)
#+end_src

* Unset file-name-handler-alist temporarily

Emacs consults this variable every time a file is read or library loaded, or
when certain functions in the file API are used (like expand-file-name or
file-truename).

Emacs does this to check if a special handler is needed to read that file, but
none of them are (typically) necessary at startup, so we disable them
(temporarily!):

#+begin_src emacs-lisp
  (defvar my/default-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
#+end_src

* Ensure init files are byte compiled

This block will byte compile ~early-init.el~ and ~init.el~ if an existing
~.elc~ file is not up to date with their contents.

#+begin_src emacs-lisp
  (autoload 'byte-recompile-file "bytecomp")
  (byte-recompile-file
   (expand-file-name "early-init.el" user-emacs-directory)
   'nil 0 'nil)
  (byte-recompile-file
   (expand-file-name "init.el" user-emacs-directory)
   'nil 0 'nil)
#+end_src

* Emacs configuration with no packages

I like to split up my "vanilla" Emacs configuration and custom functions from
the customisations provided by third party libraries that have been installed
using ~package.el~ and ~use-package~.

This way it makes it very easy to run a semi-stock Emacs without ~package.el~
or any third party libraries, but still have some saner defaults and some extra
functionality.

** Aligning symbols

Some handy functions to make aligning symbols less painful.

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/align-symbol (begin end symbol)
    "Align any SYMBOL in region (between BEGIN and END)."
    (interactive "r\nsEnter align symbol: ")
    (align-regexp begin end (concat "\\(\\s-*\\)" symbol) 1 1))
  (global-set-key (kbd "C-c a") 'my/align-symbol)

  ;;;###autoload
  (defun my/align-equals (begin end)
    "Align equals in region (between BEGIN and END)."
    (interactive "r")
    (my/align-symbol begin end "="))
  (global-set-key (kbd "C-c =") 'my/align-equals)

  ;;;###autoload
  (defun my/align-colon (begin end)
    "Align colons in region (between BEGIN and END)."
    (interactive "r")
    (my/align-symbol begin end ":"))
  (global-set-key (kbd "C-c :") 'my/align-colon)

  ;;;###autoload
  (defun my/align-numbers (begin end)
    "Align numbers in region (between BEGIN and END)."
    (interactive "r")
    (my/align-symbol begin end "[0-9]+"))
  (global-set-key (kbd "C-c #") 'my/align-numbers)

  (defadvice align-regexp (around align-regexp-with-spaces activate)
    "Force alignment commands to use spaces, not tabs."
    (let ((indent-tabs-mode nil))
      ad-do-it))
#+end_src

** ANSI color

Make compilation buffers more colorful

#+begin_src emacs-lisp
  (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
  ;;;###autoload
  (defun colorize-compilation-buffer ()
    "ANSI color in compilation buffer."
    (ansi-color-apply-on-region compilation-filter-start (point)))
  (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
  (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+end_src

** Buffers

A collection of useful functions for manipulating buffers in various ways that
I've collected (stolen!) or written over the years.

*** Fill Buffer

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/fill-buffer ()
    "Fill the contents of a buffer."
    (interactive)
    (fill-region (point-min) (point-max)))
#+end_src

*** Indent Buffer

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/indent-buffer ()
    "Indent the contents of a buffer."
    (interactive)
    (indent-region (point-min) (point-max)))
#+end_src

*** Kill this buffer

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/kill-this-buffer ()
    "Kill the current buffer - `kill-this-buffer' is unreliable."
    (interactive)
    (kill-buffer (current-buffer)))
#+end_src

*** Last buffer

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/last-buffer ()
    "Switch back and forth between two buffers easily."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer) 1)))
#+end_src

*** Nuke buffers

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/nuke-buffers ()
    "Kill all buffers, leaving *scratch* only."
    (interactive)
    (mapc
     (lambda (buffer)
       (kill-buffer buffer))
     (buffer-list))
    (if current-prefix-arg
        (delete-other-windows)))
#+end_src

*** Save buffers silently

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/save-buffers-silently ()
    "Save all open buffers without prompting."
    (interactive)
    (save-some-buffers t)
    (message "Saving all buffers..."))
#+end_src

*** Search all buffers

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/search-all-buffers (regexp)
    "Search all buffers for REGEXP."
    (interactive "sRegexp: ")
    (multi-occur-in-matching-buffers "." regexp t))
#+end_src

*** Toggle buffer

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/toggle-buffer (buffer)
    "Toggle back & forth between BUFFER and the current buffer."
    (interactive "BBuffer: ")
    (if (equal (buffer-name) buffer)
        (my/last-buffer)
      (switch-to-buffer buffer)))
#+end_src

*** Toggle messages buffer

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/toggle-messages ()
    "Toggle *Messages* buffer."
    (interactive)
    (my/toggle-buffer "*Messages*"))
#+end_src

*** Toggle scratch buffer

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/toggle-scratch ()
    "Togggle *scratch* buffer."
    (interactive)
    (my/toggle-buffer "*scratch*"))
#+end_src

*** Toggle maximize buffer

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/toggle-maximize-buffer ()
    "Temporarily maximize a buffer."
    (interactive)
    (if (= 1 (length (window-list)))
        (jump-to-register '_)
      (progn
        (window-configuration-to-register '_)
        (delete-other-windows))))
#+end_src

*** Buffer keybindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c b") 'my/last-buffer)
  (global-set-key (kbd "C-c C-b") 'my/toggle-buffer)
  (global-set-key (kbd "C-c z") 'my/toggle-maximize-buffer)
  (global-set-key (kbd "C-c M-n") 'my/nuke-buffers)
  (global-set-key (kbd "C-c s") 'my/save-buffers-silently)
  (global-set-key (kbd "C-x k") 'my/kill-this-buffer)
  (global-set-key (kbd "M-s s") 'my/search-all-buffers)
  (global-set-key (kbd "C-c M-t m") 'my/toggle-messages)
  (global-set-key (kbd "C-c M-t s") 'my/toggle-scratch)

  (global-set-key (kbd "C-x M-e") 'eval-buffer)
  (global-set-key (kbd "C-x c") 'save-buffers-kill-emacs)
  (autoload 'ibuffer "ibuffer" nil t)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "C-x M-k") 'kill-buffer)

  (add-hook 'before-save-hook 'my/indent-buffer)
#+end_src

*** Uniquify

#+begin_src emacs-lisp
  (with-eval-after-load 'uniquify
    (setq uniquify-buffer-name-style 'forward)
    (setq uniquify-strip-common-suffix t)
    (setq uniquify-after-kill-buffer-p t)
    (message "Lazy loaded uniquify :-)"))
#+end_src

** Change numbers
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/change-number-at-point (change)
    "Change a number by CHANGE amount."
    (let ((number (number-at-point))
          (point (point)))
      (when number
        (progn
          (forward-word)
          (search-backward (number-to-string number))
          (replace-match (number-to-string (funcall change number)))
          (goto-char point)))))

  ;;;###autoload
  (defun my/increment-number-at-point ()
    "Increment number at point."
    (interactive)
    (my/change-number-at-point '1+))

  ;;;###autoload
  (defun my/decrement-number-at-point ()
    "Decrement number at point."
    (interactive)
    (my/change-number-at-point '1-))

  (global-set-key (kbd "C-c +") 'my/increment-number-at-point)
  (global-set-key (kbd "C-c -") 'my/decrement-number-at-point)
#+end_src
** Change pairs
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/change-pairs (from-chars to-chars)
    "Change pairs from FROM-CHARS to TO-CHARS.

  When called in Lisp program, FROM-CHARS or TO-CHARS is a string
  of bracket pair, eg \"(paren)\", \"[bracket]\", etc.  The first
  and last characters are used.

  If the string contains “,2”, then the first 2 chars and last 2
  chars are used, for example \"[[bracket,2]]\".  If to-chars is
  equal to string “none”, the brackets are deleted.

  If the string has length greater than 2, the rest are ignored."
    (interactive
     (let (($bracketsList
            '("(paren)"
              "{brace}"
              "<greater>"
              "<<double greater,2>>"
              "`emacs'"
              "`markdown`"
              "~tilde~"
              "=equal="
              "\"quote\""
              "[square]"
              "[[double square,2]]"
              "'single quote'"
              "none"
              )))
       (list
        (completing-read "From:" $bracketsList )
        (completing-read "To:" $bracketsList ))))
    (let ( $p1 $p2 )
      (if (use-region-p)
          (progn
            (setq $p1 (region-beginning))
            (setq $p2 (region-end)))
        (save-excursion
          (if (re-search-backward "\n[ \t]*\n" nil "move")
              (progn (re-search-forward "\n[ \t]*\n")
                     (setq $p1 (point)))
            (setq $p1 (point)))
          (if (re-search-forward "\n[ \t]*\n" nil "move")
              (progn (re-search-backward "\n[ \t]*\n")
                     (setq $p2 (point)))
            (setq $p2 (point)))))
      (save-excursion
        (save-restriction
          (narrow-to-region $p1 $p2)
          (let ( (case-fold-search nil)
                 $fromLeft
                 $fromRight
                 $toLeft
                 $toRight)
            (cond
             ((string-match ",2" from-chars  )
              (progn
                (setq $fromLeft (substring from-chars 0 2))
                (setq $fromRight (substring from-chars -2))))
             (t
              (progn
                (setq $fromLeft (substring from-chars 0 1))
                (setq $fromRight (substring from-chars -1)))))
            (cond
             ((string-match ",2" to-chars)
              (progn
                (setq $toLeft (substring to-chars 0 2))
                (setq $toRight (substring to-chars -2))))
             ((string-match "none" to-chars)
              (progn
                (setq $toLeft "")
                (setq $toRight "")))
             (t
              (progn
                (setq $toLeft (substring to-chars 0 1))
                (setq $toRight (substring to-chars -1)))))
            (cond
             ((string-match "markdown" from-chars)
              (progn
                (goto-char (point-min))
                (while
                    (re-search-forward "`\\([^`]+?\\)`" nil t)
                  (replace-match (concat $toLeft "\\1" $toRight ) "FIXEDCASE" ))))
             ((string-match "tilde" from-chars)
              (progn
                (goto-char (point-min))
                (while
                    (re-search-forward "~\\([^~]+?\\)~" nil t)
                  (replace-match (concat $toLeft "\\1" $toRight ) "FIXEDCASE" ))))
             ((string-match "ascii quote" from-chars)
              (progn
                (goto-char (point-min))
                (while
                    (re-search-forward "\"\\([^\"]+?\\)\"" nil t)
                  (replace-match (concat $toLeft "\\1" $toRight ) "FIXEDCASE" ))))
             ((string-match "equal" from-chars)
              (progn
                (goto-char (point-min))
                (while
                    (re-search-forward "=\\([^=]+?\\)=" nil t)
                  (replace-match (concat $toLeft "\\1" $toRight ) "FIXEDCASE" ))))
             (t (progn
                  (progn
                    (goto-char (point-min))
                    (while (search-forward $fromLeft nil t)
                      (replace-match $toLeft "FIXEDCASE" "LITERAL")))
                  (progn
                    (goto-char (point-min))
                    (while (search-forward $fromRight nil t)
                      (replace-match $toRight "FIXEDCASE" "LITERAL")))))))))))

  (global-set-key (kbd "C-c M-p") 'my/change-pairs)
#+end_src
** File encoding stuff
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/convert-to-unix-coding-system ()
    "Change the current buffer's file encoding to unix."
    (interactive)
    (let ((coding-str (symbol-name buffer-file-coding-system)))
      (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
        (set-buffer-file-coding-system 'unix))))
  (global-set-key (kbd "C-x RET u") 'my/convert-to-unix-coding-system)

  ;;;###autoload
  (defun my/hide-dos-eol ()
    "Do not show ^M in files containing mixed UNIX and DOS line endings."
    (interactive)
    (setq buffer-display-table (make-display-table))
    (aset buffer-display-table ?\^M []))
  (add-hook 'find-file-hook 'my/hide-dos-eol)

  (setq-default buffer-file-coding-system 'utf-8-unix)
  (setq-default default-buffer-file-coding-system 'utf-8-unix)
  (setq coding-system-for-read 'utf-8-unix)
  (setq coding-system-for-write 'utf-8-unix)
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8-unix)
  (prefer-coding-system 'utf-8-unix)
#+end_src
** Complilation related
#+begin_src emacs-lisp
  (defvar my/directories-to-recompile
    '("site-lisp")
    "Directories under `user-emacs-directory' that we use for configuration.")

  (defvar my/files-to-recompile
    '("early-init.el" "init.el" "use.el")
    "Files under `user-emacs-directory' that we use for configuration.")

  ;;;###autoload
  (defun my/recompile-site-lisp ()
    "Recompile everything in Emacs configuration."
    (interactive)
    (mapc (lambda (directory) (byte-recompile-directory (concat user-emacs-directory directory) 0 t))
          my/directories-to-recompile)
    (mapc (lambda (file) (byte-recompile-file (concat user-emacs-directory file) 0))
          my/files-to-recompile))

  ;;;###autoload
  (defun my/auto-recompile ()
    "Automatically recompile Emacs Lisp files whenever they are saved."
    (when (equal major-mode 'emacs-lisp-mode)
      (progn
        (byte-compile-file buffer-file-name t)
        (message (concat "Re-compiled " buffer-file-name)))))

  (setq compilation-scroll-output 'first-error)

  (add-hook 'after-save-hook 'my/auto-recompile)
#+end_src
** Dabbrev
#+begin_src emacs-lisp
  (with-eval-after-load 'dabbrev
    (setq abbrev-file-name (concat user-emacs-directory "abbrevs"))
    (setq save-abbrevs 'silently)

    (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
    (setq dabbrev-abbrev-skip-leading-regexp "[$*/=']")
    (setq dabbrev-backward-only nil)
    (setq dabbrev-case-distinction 'case-replace)
    (setq dabbrev-case-fold-search t)
    (setq dabbrev-case-replace 'case-replace)
    (setq dabbrev-check-other-buffers t)
    (setq dabbrev-eliminate-newlines t)
    (setq dabbrev-upcase-means-case-search t)

    (message "Lazy loaded dabbrev :-)"))

  ;;;###autoload
  (defun my/hippie-expand-completions (&optional hippie-expand-function)
    "Return the full list of completions generated by HIPPIE-EXPAND-FUNCTION.
  The optional argument can be generated with `make-hippie-expand-function'."
    (let ((this-command 'my/hippie-expand-completions)
          (last-command last-command)
          (buffer-modified (buffer-modified-p))
          (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
      (cl-flet ((ding)) ; avoid the (ding) when hippie-expand exhausts its options.
        (while (progn
                 (funcall hippie-expand-function nil)
                 (setq last-command 'my/hippie-expand-completions)
                 (not (equal he-num -1)))))
      ;; Evaluating the completions modifies the buffer, however we will finish
      ;; up in the same state that we began.
      (set-buffer-modified-p buffer-modified)
      ;; Provide the options in the order in which they are normally generated.
      (delete he-search-string (reverse he-tried-table))))

  ;;;###autoload
  (defun my/hippie-complete-with (hippie-expand-function)
    "Offer `completing-read' using the specified HIPPIE-EXPAND-FUNCTION."
    (let* ((options (my/hippie-expand-completions hippie-expand-function))
           (selection (and options (completing-read "Completions: " options))))
      (if selection
          (he-substitute-string selection t)
        (message "No expansion found"))))

  ;;;###autoload
  (defun my/hippie-expand-completing-read ()
    "Offer `completing-read' for the word at point."
    (interactive)
    (my/hippie-complete-with 'hippie-expand))

  (add-hook 'text-mode-hook 'abbrev-mode)
  (global-set-key (kbd "M-/") 'hippie-expand)
  (global-set-key (kbd "C-c /") 'my/hippie-expand-completing-read)
#+end_src
** Dired
#+begin_src emacs-lisp
  (with-eval-after-load 'dired
  ;;;###autoload
    (defun my/dired-get-size ()
      "Get cumlative size of marked or current item."
      (interactive)
      (let ((files (dired-get-marked-files)))
        (with-temp-buffer
          (apply 'call-process "/usr/bin/du" nil t nil "-sch" files)
          (message "Size of all marked files: %s"
                   (progn
                     (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$")
                     (match-string 1))))))

  ;;;###autoload
    (defun my/dired-open-marked-files ()
      "Open marked files."
      (interactive)
      (let ((distinguish-one-marked nil))
        (mapc 'find-file
              (dired-map-over-marks
               (dired-get-file-for-visit)
               current-prefix-arg))))

  ;;;###autoload
    (defun my/dired-sort ()
      "Sort dired dir listing in different ways.  Prompt for a choice."
      (interactive)
      (let (-sort-by -arg)
        (if (eq system-type 'berkeley-unix)
            (progn
              (setq -sort-by (completing-read
                              "Sort by:" '( "date" "size" "name")))
              (cond ((equal -sort-by "name") (setq -arg "-alhpL"))
                    ((equal -sort-by "date") (setq -arg "-alhpLt"))
                    ((equal -sort-by "size") (setq -arg "-alhpLS "))
                    (t (error "Logic error 09535" ))))
          (progn
            (setq -sort-by (completing-read
                            "Sort by:" '( "date" "size" "name" "dir")))
            (cond ((equal -sort-by "name")
                   (setq -arg "-Al --si --time-style long-iso "))
                  ((equal -sort-by "date")
                   (setq -arg "-Al --si --time-style long-iso -t"))
                  ((equal -sort-by "size")
                   (setq -arg "-Al --si --time-style long-iso -S"))
                  ((equal -sort-by "dir")
                   (setq -arg "-Al --si --time-style long-iso --group-directories-first"))
                  (t (error "Logic error 09535" )))))
        (dired-sort-other -arg )))

  ;;;###autoload
    (defun my/dired-back-to-top ()
      "Go to first file in directory."
      (interactive)
      (goto-char (point-min))
      (dired-next-line 2))

  ;;;###autoload
    (defun my/dired-jump-to-bottom ()
      "Go to last file in directory."
      (interactive)
      (goto-char (point-max))
      (dired-next-line -1))

  ;;;###autoload
    (defun my/dired-view-file-other-window ()
      "View current file in read-only temporary buffer and other window."
      (interactive)
      (if (not (window-parent))
          (split-window-sensibly))
      (let ((file (dired-get-file-for-visit))
            (dbuffer (current-buffer)))
        (other-window 1)
        (unless (equal dbuffer (current-buffer))
          (if (or view-mode (equal major-mode 'dired-mode))
              (kill-buffer)))
        (let ((filebuffer (get-file-buffer file)))
          (if filebuffer
              (switch-to-buffer filebuffer)
            (view-file file))
          (other-window -1))))

  ;;;###autoload
    (defun my/dired-view-file-other-window-temporarily ()
      "View current file in read-only temporary buffer and other window.
  Delete the visiting buffer as soon as another key is pressed."
      (interactive)
      (dired-find-file-other-window)
      (other-window 1)
      (isearch-unread (read-event))
      (other-window 1)
      (kill-buffer)
      (other-window 1))

    (defgroup my/dired-peep nil
      "See the file at point when browsing in a Dired buffer."
      :group 'dired)

    (setq my/dired-peep-next-current-buffer nil)

  ;;;###autoload
    (defun my/dired-peep-next ()
      (interactive)
      (next-line 1)
      (dired-find-file-other-window)
      (if my/dired-peep-next-current-buffer (kill-buffer my/dired-peep-next-current-buffer))
      (setq my/dired-peep-next-current-buffer (current-buffer))
      (other-window 1))

  ;;;###autoload
    (defun my/dired-peep-previous ()
      (interactive)
      (previous-line 1)
      (dired-find-file-other-window)
      (if my/dired-peep-next-current-buffer (kill-buffer my/dired-peep-next-current-buffer))
      (setq my/dired-peep-next-current-buffer (current-buffer))
      (other-window 1))

  ;;;###autoload
    (define-minor-mode my/dired-peep-mode
      "Toggle preview of files when browsing in a Dired buffer."
      :global t
      :group 'my/dired-peep
      (if my/dired-peep-mode
          (progn
            (define-key dired-mode-map "n" 'my/dired-peep-next)
            (define-key dired-mode-map "p" 'my/dired-peep-previous))
        (define-key dired-mode-map "n" 'dired-next-line)
        (define-key dired-mode-map "p" 'dired-previous-line)))

    (defalias 'ranger-mode 'my/dired-peep-mode)

    (defvar dired-compress-files-alist
      '(("\\.tar\\.gz\\'" . "tar -c %i | gzip -c9 > %o")
        ("\\.zip\\'" . "zip %o -r --filesync %i"))
      "Control the compression shell command for `dired-do-compress-to'.

  Each element is (REGEXP . CMD), where REGEXP is the name of the
  archive to which you want to compress, and CMD the the
  corresponding command.

  Within CMD, %i denotes the input file(s), and %o denotes the
  output file.  %i path(s) are relative, while %o is absolute.")

    (autoload 'dired-omit-mode "dired-x"
      "Omit files from dired listings." t)

    (autoload 'dired-omit-files "dired-x"
      "User regex to specify what files to omit." t)

    (when (eq system-type 'berkeley-unix)
      (setq dired-listing-switches "-alhpL"))

    (when (eq system-type 'gnu/linux)
      (setq dired-listing-switches
            "-AGFhlv --group-directories-first --time-style=long-iso"))

    (setq dired-omit-files "\\`[.]?#\\|\\`[.][.]?\\'\\|^\\..+$")
    (setq dired-dwim-target t
          delete-by-moving-to-trash t
          dired-use-ls-dired nil
          dired-recursive-copies 'always
          dired-recursive-deletes 'always)

    (defun my/dired-up-directory ()
      (interactive)
      (find-alternate-file ".."))

    (define-key dired-mode-map "b" 'my/dired-up-directory)
    (define-key dired-mode-map "f" 'dired-find-alternate-file)
    (define-key dired-mode-map "c" 'dired-do-compress-to)
    (define-key dired-mode-map ")" 'dired-omit-mode)

    (define-key dired-mode-map "r" 'ranger-mode)
    (define-key dired-mode-map (kbd "C-o") 'my/dired-view-file-other-window-temporarily)
    (define-key dired-mode-map (kbd "M-o") 'my/dired-view-file-other-window)
    (define-key dired-mode-map "s" 'my/dired-sort)
    (define-key dired-mode-map "?" 'my/dired-get-size)
    (define-key dired-mode-map (kbd "C-RET") 'my/dired-open-marked-files)
    (define-key dired-mode-map (vector 'remap 'end-of-buffer) 'my/dired-jump-to-bottom)
    (define-key dired-mode-map (vector 'remap 'beginning-of-buffer) 'my/dired-back-to-top)

    (message "Lazy loaded dired :-)"))

  (with-eval-after-load 'dired-aux
    (setq dired-isearch-filenames 'dwim)
    ;; The following variables were introduced in Emacs 27.1
    (when (not (version< emacs-version "27.1"))
      (setq dired-create-destination-dirs 'ask)
      (setq dired-vc-rename-file t))
    (message "Lazy loaded dired-aux :-)"))

  (with-eval-after-load 'find-dired
    ;; (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
    (setq find-ls-option
          '("-ls" . "-AGFhlv --group-directories-first --time-style=long-iso"))
    (setq find-name-arg "-iname")
    (message "Lazy loaded find-dired :-)"))

  (with-eval-after-load 'wdired
    (setq wdired-allow-to-change-permissions t)
    (setq wdired-create-parent-directories t)
    (message "Lazy loaded wdired :-)"))

  (autoload 'dired "dired" nil t)

  ;; has to come outside of with-eval-after-load otherwise we have no dired-jump
  (autoload 'dired-jump "dired-x" ;; bound to C-x C-j by default
    "Jump to Dired buffer corresponding to current buffer." t)
  (global-set-key (kbd "C-x C-j") 'dired-jump)

  (autoload 'dired-jump-other-window "dired-x" ;; bound to C-x 4 C-j by default.
    "Like \\[dired-jump] (dired-jump) but in other window." t)
  (define-key ctl-x-4-map "C-j" 'dired-jump-other-window)

  (add-hook 'dired-mode-hook 'hl-line-mode)
#+end_src
** Ediff
#+begin_src emacs-lisp
  (with-eval-after-load 'ediff
    (setq ediff-diff-options "-w")
    (setq ediff-keep-variants nil)
    (setq ediff-make-buffers-readonly-at-startup nil)
    (setq ediff-merge-revisions-with-ancestor t)
    (setq ediff-show-clashes-only t)
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    (add-hook 'ediff-after-quit-hook-internal 'winner-undo)

    ;; https://emacs.stackexchange.com/a/24602
    ;;;###autoload
    (defun disable-y-or-n-p (orig-fun &rest args)
      "Advise ORIG-FUN with ARGS so it dynamically rebinds `y-or-n-p'."
      (cl-letf (((symbol-function 'y-or-n-p) (lambda () t)))
        (apply orig-fun args)))

    (advice-add 'ediff-quit :around #'disable-y-or-n-p)

    (message "Lazy loaded ediff :-)"))
#+end_src
** Editing
*** Delete inside delimiters

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/delete-inside ()
    "Deletes the text within parentheses, brackets or quotes."
    (interactive)
    ;; Search for a match on the same line, don't delete across lines
    (search-backward-regexp "[[{(<\"\']" (line-beginning-position))
    (forward-char)
    (let ((lstart (point)))
      (search-forward-regexp "[]})>\"\']" (line-end-position))
      (backward-char)
      (kill-region lstart (point))))
#+end_src

*** Generate a numbered list

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/generate-numbered-list (start end char)
    "Create a numbered list from START to END.  Using CHAR as punctuation."
    (interactive "nStart number:\nnEnd number:\nsCharacter:")
    (let ((x start))
      (while (<= x end)
        (insert (concat (number-to-string x) char))
        (newline)
        (setq x (+ x 1)))))
#+end_src

*** Insert a timestamp at the point

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/insert-date ()
    "Insert a timestamp according to locale's date and time format."
    (interactive)
    (insert (format-time-string "%c" (current-time))))
#+end_src

*** Open a line above the current line

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/open-line-above ()
    "Insert an empty line above the current line.

  Position the cursor at its beginning, according to the current
  mode."
    (interactive)
    (move-beginning-of-line nil)
    (insert "\n")
    (if electric-indent-inhibit
        ;; We can't use `indent-according-to-mode' in languages like Python,
        ;; as there are multiple possible indentations with different meanings.
        (let* ((indent-end (progn (move-to-mode-line-start) (point)))
               (indent-start (progn (move-beginning-of-line nil) (point)))
               (indent-chars (buffer-substring indent-start indent-end)))
          (forward-line -1)
          ;; This new line should be indented with the same characters as
          ;; the current line.
          (insert indent-chars))
      ;; Just use the current major-mode's indent facility.
      (forward-line -1)
      (indent-according-to-mode)))
#+end_src

*** Open a line below the current line

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/open-line-below (arg)
    "Insert an empty line after the current line.

  Position the cursor at its beginning, according to the current
  mode.  With a prefix ARG open line above the current line."
    (interactive "P")
    (if arg
        (my/open-line-above)
      (move-end-of-line nil)
      (newline-and-indent)))
#+end_src

*** Sort lines in an case insensitive manner

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/sort-lines-nocase ()
    "Sort marked lines with case sensitivity."
    (interactive)
    (let ((sort-fold-case t))
      (call-interactively 'sort-lines)))
#+end_src

*** Surround stuff

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/surround (begin end open close)
    "Put OPEN at BEGIN and CLOSE at END of the region.

  If you omit CLOSE, it will reuse OPEN."
    (interactive  "r\nsStart: \nsEnd: ")
    (save-excursion
      (goto-char end)
      (if (string= close "")
          (insert open)
        (insert close))
      (goto-char begin)
      (insert open)))
#+end_src

*** Underline text

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/underline-text (arg)
    "Insert ARG under the current line.

  Filled with a default underline character `='.

  If point had been at the end of the line, moves point to the
  beginning of the line directly following the underlining.

  It does not underline the line's leading whitespace, trailing
  whitespace, or comment symbols.

  With prefix prompts user for a custom underline character.

  With double prefix, does not underline whitespace embedded in the
  line."
    (interactive "p")
    (let* ((original-point (point))
           (underline-char
            (replace-regexp-in-string "[[:cntrl:][:space:]]" "="
                                      (if (= arg 1)
                                          "="
                                        (char-to-string
                                         (read-char "What character to underline with?")))))
           (original-point-is-eol
            (when (looking-at "$") t))
           (original-point-is-eob
            (= original-point (point-max))))
      (beginning-of-line)
      (unless
          (when (looking-at "[[:space:]]*$")
            (beginning-of-line 0)
            (when (looking-at "[[:space:]]*$")
              (goto-char original-point)
              (message "nothing to do")))
        (insert
         (buffer-substring (line-beginning-position) (line-end-position))
         "\n")
        (save-restriction
          (narrow-to-region
           (progn
             (goto-char (1- (re-search-forward "[^[:space:]]" nil t)))
             (cond
              ((looking-at ";+")   (match-end 0))
              ((looking-at "#+")   (match-end 0))
              ((looking-at "//+")  (match-end 0))
              ((looking-at "/\\*+") (match-end 0))
              (t (point))))
           (1+ (progn
                 (goto-char (line-end-position))
                 (re-search-backward "[^[:space:]]" nil t))))
          (untabify (point-min) (point-max))
          (goto-char (point-min))
          (if (= arg 16)
              (while (re-search-forward "[^[:space:]]" nil t)
                (replace-match underline-char nil))
            (re-search-forward "[^[:space:]]" nil t)
            (goto-char (1- (point)))
            (while (re-search-forward "." nil t)
              (replace-match underline-char nil)))
          (widen))
        (if original-point-is-eob
            (goto-char (point-max))
          (if original-point-is-eol
              (goto-char (re-search-forward "^"))
            (goto-char original-point))))))
#+end_src

*** Untabify a buffer (fuck spaces!)

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/untabify-buffer ()
    "Convert all tabs to spaces in the buffer."
    (interactive)
    (untabify (point-min) (point-max)))
#+end_src

*** XML pretty print

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/xml-pretty-print ()
    "Reformat and indent XML."
    (interactive)
    (save-excursion
      (sgml-pretty-print (point-min) (point-max))
      (indent-region (point-min) (point-max))))
#+end_src

*** Yank pop forwards

#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/yank-pop-forwards (arg)
    "Cycle forwards through the kill.  Reverse `yank-pop'.  With ARG."
    (interactive "p")
    (yank-pop (- arg)))
#+end_src

*** Custom editing function bindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c d") 'my/delete-inside)
  (global-set-key (kbd "C-c u") 'my/underline-text)
  (global-set-key (kbd "M-s M-s") 'my/surround)
  (global-set-key (kbd "C-o") 'my/open-line-above)
  (global-set-key (kbd "C-S-o") 'my/open-line-below)
  (global-set-key (kbd "C-M-y") 'my/yank-pop-forwards)
#+end_src

*** Editing related keyboard built-in keybindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c C-e") 'pp-eval-last-sexp)
  (global-set-key (kbd "M-;") 'comment-line)
  (global-set-key (kbd "C-z") 'zap-up-to-char)
  (global-set-key (kbd "M-z") 'zap-up-char)
  (global-set-key (kbd "C-x M-t") 'transpose-regions)
  (global-set-key (kbd "C-x M-p") 'transpose-paragraphs)
  (global-set-key (kbd "M-SPC") 'cycle-spacing)
  (global-set-key (kbd "M-%") 'query-replace-regexp)
#+end_src

*** DWIM replacements for changing case

#+begin_src emacs-lisp
  (global-set-key [remap capitalize-word] 'capitalize-dwim)
  (global-set-key [remap downcase-word] 'downcase-dwim)
  (global-set-key [remap upcase-word] 'upcase-dwim)
#+end_src

** ERC
#+begin_src emacs-lisp
  (with-eval-after-load 'erc
    (setq erc-autojoin-channels-alist '(("freenode.net"
                                         "#org-mode"
                                         "#emacs")))
    (setq erc-fill-column 80)
    (setq erc-hide-list '("JOIN" "PART" "QUIT"))
    (setq erc-input-line-position -2)
    (setq erc-keywords '("not2b"))
    (setq erc-nick "not2b")
    (setq erc-prompt-for-password t)
    (setq erc-track-enable-keybindings t)

    (message "Lazy loaded erc :-)"))

  (autoload 'erc "erc" nil t)
#+end_src
** Eshell
#+begin_src emacs-lisp
  (with-eval-after-load 'eshell

    ;;;###autoload
    (defun my/eshell-complete-recent-dir (&optional arg)
      "Switch to a recent `eshell' directory using completion.
  With \\[universal-argument] also open the directory in a `dired'
  buffer."
      (interactive "P")
      (let* ((dirs (ring-elements eshell-last-dir-ring))
             (dir (completing-read "Switch to recent dir: " dirs nil t)))
        (insert dir)
        (eshell-send-input)
        (when arg
          (dired dir))))

    ;;;###autoload
    (defun my/eshell-complete-history ()
      "Insert element from `eshell' history using completion."
      (interactive)
      (let ((hist (ring-elements eshell-history-ring)))
        (insert
         (completing-read "Input history: " hist nil t))))

    ;;;###autoload
    (defun my/eshell-prompt ()
      "Custom eshell prompt."
      (concat
       (propertize (user-login-name) 'face `(:foreground "green" ))
       (propertize "@" 'face `(:foreground "yellow"))
       (propertize (system-name) `face `(:foreground "green"))
       (propertize ":" 'face `(:foreground "yellow"))
       (if (string= (eshell/pwd) (getenv "HOME"))
           (propertize "~" 'face `(:foreground "magenta"))
         (propertize (eshell/basename (eshell/pwd)) 'face `(:foreground "magenta")))
       (propertize (ignore-errors (format " (%s)"
                                          (vc-responsible-backend default-directory)))
                   'face `(:foreground "cyan"))
       "\n"
       (if (= (user-uid) 0)
           (propertize "#" 'face `(:foreground "red"))
         (propertize "$" 'face `(:foreground "yellow")))
       (propertize " " 'face `(:foreground "white"))))

    ;; https://www.emacswiki.org/emacs/EshellPrompt
    (setq
     eshell-cd-on-directory t
     eshell-destroy-buffer-when-process-dies t
     eshell-highlight-prompt nil
     eshell-hist-ignoredups t
     eshell-history-size 4096
     eshell-ls-use-colors t
     eshell-prefer-lisp-functions t
     eshell-prefer-lisp-variables t
     eshell-prompt-regexp "^[^#$\n]*[#$] "
     eshell-prompt-function 'my/eshell-prompt
     eshell-review-quick-commands nil
     eshell-save-history-on-exit t
     eshell-smart-space-goes-to-end t
     eshell-where-to-jump 'begin)

    (add-to-list 'eshell-modules-list 'eshell-tramp) ;; no sudo password with ~/.authinfo
    (add-hook 'eshell-preoutput-filter-functions 'ansi-color-apply)

    (defun my/eshell-keys()
      (define-key eshell-mode-map (kbd "M-r") 'my/eshell-complete-history)
      (define-key eshell-mode-map (kbd "C-=") 'my/eshell-complete-recent-dir))

    (add-hook 'eshell-mode-hook 'my/eshell-keys)

    (message "Lazy loaded eshell :-)"))

  ;;;###autoload
  (defun my/eshell-other-window ()
    "Open an `eshell' in another window."
    (interactive)
    (split-window-sensibly)
    (other-window 1)
    (eshell))

  (autoload 'eshell "eshell" nil t)
  (global-set-key (kbd "C-c e") 'eshell)
  (global-set-key (kbd "C-c 4 e") 'my/eshell-other-window)
#+end_src
** Files
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/delete-this-file ()
    "Delete the current file, and kill the buffer."
    (interactive)
    (or (buffer-file-name) (error "No file is currently being edited"))
    (when (yes-or-no-p (format "Really delete '%s'?"
                               (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name))
      (kill-this-buffer)))

  ;;;###autoload
  (defun my/copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))

  ;;;###autoload
  (defun my/make-backup ()
    "Make a backup copy of current file or dired marked files.

  If in dired, backup current file or marked files."
    (interactive)
    (let (($fname (buffer-file-name)))
      (if $fname
          (let (($backup-name
                 (concat $fname "." (format-time-string "%y%m%d%H%M") ".bak")))
            (copy-file $fname $backup-name t)
            (message (concat "Backup saved at: " $backup-name)))
        (if (string-equal major-mode "dired-mode")
            (progn
              (mapc (lambda ($x)
                      (let (($backup-name
                             (concat $x "." (format-time-string "%y%m%d%H%M") ".bak")))
                        (copy-file $x $backup-name t)))
                    (dired-get-marked-files))
              (message "marked files backed up"))
          (user-error "Buffer not file nor dired")))))

  ;;;###autoload
  (defun my/make-backup-and-save ()
    "Backup of current file and save, or backup dired marked files.
  For detail, see `my/make-backup'."
    (interactive)
    (if (buffer-file-name)
        (progn
          (my/make-backup)
          (when (buffer-modified-p)
            (save-buffer)))
      (progn
        (my/make-backup))))

  ;;;###autoload
  (defun my/rename-this-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "FNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (unless filename
        (error "Buffer '%s' is not visiting a file!" name))
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (when (file-exists-p filename)
            (rename-file filename new-name 1))
          (rename-buffer new-name)
          (set-visited-file-name new-name)))))

  ;;;###autoload
  (defun my/read-file (file)
    "Return FILE content as a string."
    (with-temp-buffer
      (insert-file-contents file)
      (buffer-string)))

  ;;;###autoload
  (defun my/read-lines (file)
    "Return a list of lines of a FILE."
    (with-temp-buffer
      (insert-file-contents file)
      (split-string (buffer-string) "\n" t)))

  ;;;###autoload
  (defun my/sudoedit (&optional arg)
    "Open current or ARG file as root."
    (interactive "P")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:"
                           (read-file-name "Find file (as root): ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

  (global-set-key (kbd "C-c f d") 'my/delete-this-file)
  (global-set-key (kbd "C-c f c") 'my/copy-file-name-to-clipboard)
  (global-set-key (kbd "C-c f b") 'my/make-backup-and-save)
  (global-set-key (kbd "C-c f r") 'my/rename-this-file-and-buffer)
  (global-set-key (kbd "C-c f s") 'my/sudoedit)
#+end_src
** Gnus
#+begin_src emacs-lisp
  (with-eval-after-load 'gnus
    (require 'nnir)
    (setq gnus-init-file "~/.emacs.d/init.el")
    (setq gnus-home-directory "~/.emacs.d/")
    (setq message-directory "~/.emacs.d/mail")
    (setq gnus-directory "~/.emacs.d/news")
    (setq nnfolder-directory "~/.emacs.d/mail/archive")
    (setq gnus-use-full-window nil)
    (setq gnus-select-method '(nntp "news.gwene.org"))
    ;; (setq gnus-secondary-select-methods '((nntp "news.gnus.org")))
    (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject)
    (setq gnus-thread-hide-subtree t)
    (setq gnus-thread-ignore-subject t)

    (message "Lazy loaded gnus :-)"))

  (autoload 'gnus "gnus" nil t)
#+end_src
** Hooks
#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
  (add-hook 'lisp-mode-hook 'eldoc-mode)
  (add-hook 'prog-mode-hook 'hl-line-mode)
  (add-hook 'text-mode-hook 'hl-line-mode)
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'yaml-mode-hook 'hs-minor-mode)
  (add-hook 'yaml-mode-hook 'display-line-numbers-mode)
#+end_src
** Icomplete
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/icomplete-styles ()
    "Set icomplete styles based on Emacs version."
    (if (version< emacs-version "27")
        (setq-local completion-styles '(initials partial-completion substring basic))
      (setq-local completion-styles '(initials partial-completion flex substring basic))))
  (add-hook 'icomplete-minibuffer-setup-hook 'my/icomplete-styles)

  (if (version< emacs-version "27")
      (icomplete-mode)
    (fido-mode))

  (setq icomplete-delay-completions-threshold 100)
  (setq icomplete-max-delay-chars 2)
  (setq icomplete-compute-delay 0.2)
  (setq icomplete-show-matches-on-no-input t)
  (setq icomplete-hide-common-prefix nil)
  (setq icomplete-prospects-height 1)
  ;; (setq icomplete-separator "\n")
  (setq icomplete-separator (propertize " · " 'face 'shadow))
  (setq icomplete-with-completion-tables t)
  (setq icomplete-tidy-shadowed-file-names t)
  (setq icomplete-in-buffer t)

  (if (version< emacs-version "27")
      (define-key icomplete-minibuffer-map (kbd "C-j") 'icomplete-fido-exit))

  (define-key icomplete-minibuffer-map (kbd "M-j") 'exit-minibuffer)
  (define-key icomplete-minibuffer-map (kbd "C-n") 'icomplete-forward-completions)
  (define-key icomplete-minibuffer-map (kbd "C-p") 'icomplete-backward-completions)
  (define-key icomplete-minibuffer-map (kbd "<up>") 'icomplete-backward-completions)
  (define-key icomplete-minibuffer-map (kbd "<down>") 'icomplete-forward-completions)
  (define-key icomplete-minibuffer-map (kbd "<left>") 'icomplete-backward-completions)
  (define-key icomplete-minibuffer-map (kbd "<right>") 'icomplete-forward-completions)
#+end_src
** Imenu
#+begin_src emacs-lisp
  (with-eval-after-load 'imenu
    (setq imenu-auto-rescan t)
    (setq imenu-auto-rescan-maxout 600000)
    (setq imenu-eager-completion-buffer t)
    (setq imenu-level-separator "/")
    (setq imenu-max-item-length 100)
    (setq imenu-space-replacement " ")
    (setq imenu-use-markers t)
    (setq imenu-use-popup-menu nil)
    (message "Lazy loaded imenu :-)"))

  (autoload 'imenu "imenu" nil t)
  (global-set-key (kbd "C-c i") 'imenu)
#+end_src
** Isearch
#+begin_src emacs-lisp
  (with-eval-after-load 'isearch
     ;;;###autoload
    (defun my/isearch-exit ()
      "Move point to the start of the matched string."
      (interactive)
      (when (eq isearch-forward t)
        (goto-char isearch-other-end))
      (isearch-exit))

    ;;;###autoload
    (defun my/isearch-abort-dwim ()
      "Delete failed `isearch' input, single char, or cancel search.

  This is a modified variant of `isearch-abort' that allows us to
  perform the following, based on the specifics of the case: (i)
  delete the entirety of a non-matching part, when present; (ii)
  delete a single character, when possible; (iii) exit current
  search if no character is present and go back to point where the
  search started."
      (interactive)
      (if (eq (length isearch-string) 0)
          (isearch-cancel)
        (isearch-del-char)
        (while (or (not isearch-success) isearch-error)
          (isearch-pop-state)))
      (isearch-update))

    ;;;###autoload
    (defun my/copy-to-isearch ()
      "Copy up to the search match when searching forward.

  When searching backward, copy to the start of the search match."
      (interactive)
      (my/isearch-exit)
      (call-interactively 'kill-ring-save)
      (exchange-point-and-mark))

    ;;;###autoload
    (defun my/kill-to-isearch ()
      "Kill up to the search match when searching forward.

  When searching backward, kill to the beginning of the match."
      (interactive)
      (my/isearch-exit)
      (call-interactively 'kill-region))

    (when (not (version< emacs-version "27.1"))
      (setq isearch-allow-scroll 'unlimited)
      (setq isearch-yank-on-move 't)
      (setq isearch-lazy-count t)
      (setq lazy-count-prefix-format nil)
      (setq lazy-count-suffix-format " (%s/%s)"))
    (setq search-highlight t)
    (setq search-whitespace-regexp ".*?")
    (setq isearch-lax-whitespace t)
    (setq isearch-regexp-lax-whitespace nil)
    (setq isearch-lazy-highlight t)

    (define-key isearch-mode-map (kbd "RET") 'my/isearch-exit)
    (define-key isearch-mode-map (kbd "<backspace>") 'my/isearch-abort-dwim)
    (define-key isearch-mode-map (kbd "M-w") 'my/copy-to-isearch)
    (define-key isearch-mode-map (kbd "C-M-w") 'my/kill-to-isearch)
    (define-key isearch-mode-map (kbd "M-/") 'isearch-complete)
    (define-key minibuffer-local-isearch-map (kbd "M-/") 'isearch-complete-edit)

    (message "Lazy loaded isearch :-)"))

  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "M-s b") 'multi-isearch-buffers-regexp)
  (global-set-key (kbd "M-s f") 'multi-isearch-files-regexp)
  (global-set-key (kbd "M-s M-o") 'multi-occur)

  (add-hook 'occur-mode-hook 'hl-line-mode)
  (define-key occur-mode-map "t" 'toggle-truncate-lines)
#+end_src
** Keys
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c M-t a") 'toggle-text-mode-autofill)
  (global-set-key (kbd "C-c M-t d E") 'toggle-debug-on-entry)
  (global-set-key (kbd "C-c M-t d e") 'toggle-debug-on-error)
  (global-set-key (kbd "C-c M-t d q") 'toggle-debug-on-quit)
  (global-set-key (kbd "C-c M-t t") 'toggle-truncate-lines)

  (global-set-key (kbd "C-c M-m") 'menu-bar-mode)
  (global-set-key (kbd "S-<f10>") 'menu-bar-mode)

  (global-set-key (kbd "C-c h n") 'highlight-changes-next-change)
  (global-set-key (kbd "C-c h p") 'highlight-changes-previous-change)

  (when (version< emacs-version "27")
    (global-set-key (kbd "C-x t t") 'tab-bar-select-tab-by-name)
    (global-set-key (kbd "C-x t c") 'tab-bar-new-tab)
    (global-set-key (kbd "C-x t k") 'tab-bar-close-tab)
    (global-set-key (kbd "C-x t n") 'tab-bar-switch-to-next-tab)
    (global-set-key (kbd "C-x t p") 'tab-bar-switch-to-prev-tab)
    (global-set-key (kbd "C-x t l") 'tab-bar-switch-to-recent-tab))

  (global-set-key (kbd "C-<f10>") 'toggle-frame-maximized)
  (global-set-key (kbd "C-<f11>") 'toggle-frame-fullscreen)
  (global-set-key (kbd "C-s-f") 'toggle-frame-fullscreen)
  (global-set-key (kbd "C-s-m") 'toggle-frame-maximized)

  (global-set-key (kbd "C-c M-d r") 'desktop-read)
  (global-set-key (kbd "C-c M-d s") 'desktop-save)

  (autoload 'calculator "calculator" nil t)
  (global-set-key (kbd "C-c c") 'calculator)
  (autoload 'calc "calc" nil t)
  (global-set-key (kbd "C-c M-c") 'calc)

  (autoload 'grep "grep" nil t)
  (global-set-key (kbd "C-c C-g") 'grep)

  ;; for help modes, and simple/special modes
  (define-key special-mode-map "n" #'forward-button)
  (define-key special-mode-map "p" #'backward-button)
  (define-key special-mode-map "f" #'forward-button)
  (define-key special-mode-map "b" #'backward-button)
  (define-key special-mode-map "n" #'widget-forward)
  (define-key special-mode-map "p" #'widget-backward)
  (define-key special-mode-map "f" #'widget-forward)
  (define-key special-mode-map "b" #'widget-backward)
#+end_src
** Marks
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/exchange-point-and-mark-no-activate ()
    "Identical to \\[exchange-point-and-mark] but will not activate the region."
    (interactive)
    (exchange-point-and-mark)
    (deactivate-mark nil))

  ;;;###autoload
  (defun my/jump-to-mark ()
    "Jump to the local mark, respecting the `mark-ring' order.

  This is the same as using \\[set-mark-command] with the prefix argument."
    (interactive)
    (set-mark-command 1))

  ;;;###autoload
  (defun my/push-mark-no-activate ()
    "Push `point' to `mark-ring', but do not activate the region.

  Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled"
    (interactive)
    (push-mark (point) t nil)
    (message "Pushed mark to ring"))

  (global-set-key (kbd "C-c SPC p") 'my/push-mark-no-activate)
  (global-set-key (kbd "C-c SPC j") 'my/jump-to-mark)
  (global-set-key (kbd "C-c SPC x") 'my/exchange-point-and-mark-no-activate)

  (global-set-key (kbd "C-x p") 'pop-to-mark-command)

  (add-hook 'before-save-hook 'my/push-mark-no-activate)
#+end_src
** Minibuffer
#+begin_src emacs-lisp
  (savehist-mode 1)
  (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
  (setq savehist-save-minibuffer-history 1)

  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  (setq completion-flex-nospace nil)
  (setq completion-ignore-case t)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-show-help nil)
  (setq completions-detailed t)
  (setq completions-format 'one-column)

  (setq enable-recursive-minibuffers t)
  (setq file-name-shadow-mode 1)
  (setq minibuffer-depth-indicate-mode 1)
  (setq minibuffer-eldef-shorten-default t)
  (setq minibuffer-electric-default-mode 1)
  (setq read-answer-short t)
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)
  (setq resize-mini-windows t)

  (add-hook 'minibuffer-setup-hook (lambda () (setq gc-cons-threshold most-positive-fixnum)))
  (add-hook 'minibuffer-exit-hook (lambda () (setq gc-cons-threshold 16777216))) ; 16mb
#+end_src
** Misc
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/substring (substring string)
    "Return SUBSTRING of a STRING."
    (let ((regex (concat  ".*\\(" substring "\\).*")))
      (string-match regex string)
      (match-string 1 string)))

  ;;;###autoload
  (defun my/cycle-line-numbers ()
    "Cycle through all the line numbering configurations."
    (interactive)
    (if display-line-numbers
        (if current-prefix-arg
            (if (eq display-line-numbers 'relative)
                (setq display-line-numbers t)
              (setq display-line-numbers 'relative))
          (setq display-line-numbers nil))
      (if current-prefix-arg
          (setq display-line-numbers 'relative)
        (setq display-line-numbers t))))

  ;;;###autoload
  (defun my/fortune ()
    "Insert a fortune into the minibuffer.

  If called with `prefix-arg', insert output of the fortune command
  into the buffer, before the point."
    (interactive)
    (if current-prefix-arg
        (insert (shell-command-to-string "fortune"))
      (message (string-trim (shell-command-to-string "fortune -s -n 100")))))

  ;;;###autoload
  (defun my/google (arg)
    "Googles a query or region.  With prefix ARG, wrap in quotes."
    (interactive "P")
    (let ((query
           (if (region-active-p)
               (buffer-substring (region-beginning) (region-end))
             (read-string "Query: "))))
      (when arg (setq query (concat "\"" query "\"")))
      (browse-url
       (concat "http://www.google.com/search?ie=utf-8&oe=utf-8&q=" query))))

  ;;;###autoload
  (defun my/kanye-west-quote ()
    "Get a random Kanye quote in the minibuffer."
    (interactive)
    (message
     (with-temp-buffer
       (url-insert-file-contents "https://api.kanye.rest/")
       (cdr (assoc 'quote (json-read))))))

  ;;;###autoload
  (defun my/chuck-norris-joke ()
    "Get a random Chuck Norris joke in the minibuffer."
    (interactive)
    (message
     (with-temp-buffer
       (url-insert-file-contents "https://api.chucknorris.io/jokes/random")
       (cdr (assoc 'value (json-read))))))

  ;;;###autoload
  (defmacro my/measure-time (&rest body)
    "Measure and return the running time of BODY."
    (declare (indent defun))
    (let ((start (make-symbol "start")))
      `(let ((,start (float-time)))
         ,@body
         (- (float-time) ,start))))

  ;;;###autoload
  (defmacro my/measure-time-2 (&rest body)
    "Measure the time it takes to evaluate BODY."
    `(let ((time (current-time)))
       ,@body
       (message "%.06f" (float-time (time-since time)))))

  (global-set-key (kbd "C-c M-g") 'my/google)
  (global-set-key (kbd "C-c M-t l") 'my/cycle-line-numbers)
  (global-set-key (kbd "C-c Q c") 'my/chuck-norris-joke)
  (global-set-key (kbd "C-c Q k") 'my/kanye-west-quote)
  (global-set-key (kbd "C-c Q f") 'my/fortune)
#+end_src
** Org
#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (require 'org-tempo)

  ;;;###autoload
    (defun my/org-recursive-sort ()
      "Sort all entries in the current buffer, recursively."
      (interactive)
      (org-map-entries
       (lambda ()
         (condition-case x
             (org-sort-entries nil ?a)
           (user-error)))))

  ;;;###autoload
    (defun my/org-tangle-block ()
      "Only tangle the block at point."
      (interactive)
      (let ((current-prefix-arg '(4)))
        (call-interactively 'org-babel-tangle)))

  ;;;###autoload
    (defun my/org-babel-insert-elisp-boilerplate (file)
      "Insert elisp documentation boilerplate into FILE, using COMMENTARY.
          Return the file name, so that this function can be piped to other
          functions."
      (when (equal (file-name-extension file) "el")
        (with-current-buffer (find-file-noselect file)
          (let* ((filename (file-name-sans-extension (file-name-nondirectory file)))
                 (copyright (concat (format-time-string "%Y") " " user-full-name))
                 (author (concat user-full-name " <"user-mail-address">"))
                 (header (concat ";;; " filename ".el --- " filename"\n\n"
                                 ";;; Commentary:\n\n"
                                 ";; Copyright: (C) " copyright "\n"
                                 ";; Author: " author "\n\n"
                                 ";;; Code:\n"))
                 (footer (concat "\n(provide '" filename ")\n"
                                 ";; Local Variables:\n"
                                 ";; indent-tabs-mode: nil\n"
                                 ";; byte-compile-warnings: (not free-vars noruntime)\n"
                                 ";; End:\n"
                                 ";;; " filename ".el ends here")))
            (goto-char (point-min)) (insert header)
            (goto-char (point-max)) (insert footer)
            (add-file-local-variable-prop-line 'lexical-binding t)
            (save-buffer) (kill-buffer)
            (message (concat "Inserted boilerplate into " file))))
        (when (file-readable-p (concat file "~"))
          (delete-file (concat file "~"))
          (message (concat "Deleted " file "~ backup file")))))
    (add-hook 'org-babel-post-tangle-hook
              (lambda () (my/org-babel-insert-elisp-boilerplate buffer-file-name)))

  ;;;###autoload
    (defun my/buffer-substring-p (string)
      (save-excursion
        (save-match-data
          (goto-char (point-min))
          (if (re-search-forward string nil t) t nil))))

  ;;;###autoload
    (defun my/org-babel-auto-tangle-init-file ()
      (if (and (equal (buffer-name) "README.org")
               (my/buffer-substring-p
                "^\\#\\+PROPERTY\\: header-args\\+ \\:tangle \\~\\/\\.emacs.d\\/init\\.el"))
          (org-babel-tangle)))
    (add-hook 'after-save-hook 'my/org-babel-auto-tangle-init-file)

    (setq org-image-actual-width nil)
    (setf org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))
    (setq org-emphasis-regexp-components '(" \t('\"{" "- \t.,:!?;'\")}\\" " \t\r\n,\"'" "." 300))
    (setq org-confirm-babel-evaluate t)
    (setq org-agenda-files (file-expand-wildcards "~/*.org"))
    (setq org-agenda-files (quote ("~/org/todo.org")))
    (setq org-default-notes-file "~/org/notes.org")
    (setq org-directory "~/org")
    (setq org-export-with-toc t)
    (setq org-indent-indentation-per-level 1)
    (setq org-list-allow-alphabetical t)
    (setq org-list-indent-offset 1)
    ;; (setq org-replace-disputed-keys t) ;; fix windmove conflicts
    (setq org-return-follows-link t)
    (setq org-refile-use-outline-path 'file)
    (setq org-outline-path-complete-in-steps nil)
    (setq org-refile-allow-creating-parent-nodes 'confirm)
    (setq org-refile-targets '((nil :maxlevel . 9)))
    (setq org-speed-commands-user (quote (("N" . org-down-element)
                                          ("P" . org-up-element))))
    (setq org-src-fontify-natively t)
    (setq org-src-tab-acts-natively t)
    (setq org-src-window-setup 'current-window)
    (setq org-startup-indented t)
    (setq org-use-fast-todo-selection t)
    (setq org-use-speed-commands t)

    (setq org-latex-listings 'minted)
    (setq org-latex-pdf-process
          '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
            "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    (add-to-list 'org-latex-packages-alist '("" "minted"))

    (setq org-capture-templates
          '(("t" "TODO Entry"
             entry (file+headline "~/org/todo.org" "CURRENT")
             "* TODO %?\n  %i\n  %a")
            ("j" "Journal Entry"
             entry (file+datetree "~/org/journal.org" "JOURNAL")
             "* %?\nEntered on %U\n  %i\n  %a")
            ("h" "Health Note"
             entry (file+headline "~/org/notes.org" "HEALTH")
             "* %?\n  %i\n  %a")
            ("m" "Misc Note"
             entry (file+headline "~/org/notes.org" "MISC")
             "* %?\n  %i\n  %a")
            ("M" "Mathematics Note"
             entry (file+headline "~/org/notes.org" "MATHEMATICS")
             "* %?\n  %i\n  %a")
            ("P" "Philosophy Note"
             entry (file+headline "~/org/notes.org" "PHILOSOPHY")
             "* %?\n  %i\n  %a")
            ("p" "Programming Note"
             entry (file+headline "~/org/notes.org" "PROGRAMMING")
             "* %?\n  %i\n  %a")
            ("s" "Sysadmin Note"
             entry (file+headline "~/org/notes.org" "SYSADMIN")
             "* %?\n  %i\n  %a")
            ("w" "Webadmin Note"
             entry (file+headline "~/org/notes.org" "WEBADMIN")
             "* %?\n  %i\n  %a")))

    (add-to-list 'org-structure-template-alist '("cl" . "src common-lisp"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("go" . "src go"))
    (add-to-list 'org-structure-template-alist '("ja" . "src java"))
    (add-to-list 'org-structure-template-alist '("js" . "src javascript"))
    (add-to-list 'org-structure-template-alist '("kr" . "src c"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("sq" . "src sql"))
    (add-to-list 'org-structure-template-alist '("tx" . "src text"))

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((awk . t)
       (C . t)
       (clojure . t)
       (css . t)
       (dot . t) ;; graphviz language
       (emacs-lisp . t)
       (gnuplot . t)
       (haskell . t)
       ;; (http . t)
       (java . t)
       (js . t)
       (latex . t)
       (lisp . t)
       (makefile . t)
       (ocaml . t)
       (perl . t)
       (python . t)
       (plantuml . t)
       (ruby . t)
       (scheme . t)
       (sed . t)
       (shell . t)
       (sql . t)
       (sqlite . t)))

    (add-hook 'org-mode-hook 'auto-fill-mode)
    (add-hook 'org-mode-hook 'hl-line-mode)
    (message "Lazy loaded org :-)"))

  (autoload 'org-mode "org" nil t)
  (autoload 'org-agenda "org" nil t)
  (global-set-key (kbd "C-c C-o a") 'org-agenda)
  (autoload 'org-capture "org" nil t)
  (global-set-key (kbd "C-c C-o c") 'org-capture)
  (autoload 'org-store-link "org" nil t)
  (global-set-key (kbd "C-c C-o l") 'org-store-link)
  (autoload 'org-time-stamp "org" nil t)
  (global-set-key (kbd "C-c C-o t") 'org-time-stamp)
#+end_src
** Recentf
#+begin_src emacs-lisp
  (with-eval-after-load 'recentf
    (setq recentf-exclude '(".gz"
                            ".xz"
                            ".zip"
                            "/elpa/"
                            "/ssh:"
                            "/sudo:"
                            "^/var/folders\\.*"
                            "COMMIT_EDITMSG\\'"
                            ".*-autoloads\\.el\\'"
                            "[/\\]\\.elpa/"))
    (setq recentf-max-menu-items 128)
    (setq recentf-max-saved-items 256)

    (global-set-key (kbd "C-c C-r") 'recentf-open-files)

    ;;;###autoload
    (defun my/completing-recentf ()
      "Show a list of recent files."
      (interactive)
      (let* ((all-files recentf-list)
             (list1 (mapcar (lambda (x) (file-name-nondirectory x) x) all-files))
             (list2 (mapcar #'substring-no-properties list1))
             (list3 (mapcar #'abbreviate-file-name list2))
             (list4 (cl-remove-duplicates list3 :test #'string-equal)))
        (find-file (completing-read "Recent Files: " list4 nil t))))

    (defun my/completing-recentf-other-window ()
      (interactive)
      (split-window-sensibly)
      (other-window 1)
      (my/completing-recentf))

    (global-set-key (kbd "C-c r") 'my/completing-recentf)
    (global-set-key (kbd "C-c 4 r") 'my/completing-recentf-other-window)

    (message "Lazy loaded recentf :-)"))

  (recentf-mode 1)
#+end_src
** Registers
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/jump-to-register-other-window ()
    "Tin job."
    (interactive)
    (split-window-sensibly)
    (other-window 1)
    (jump-to-register (register-read-with-preview "Jump to register")))

  (set-register ?h (cons 'file "~/"))
  (set-register ?s (cons 'file "~/src/"))
  (set-register ?j (cons 'file "~/src/gitlab/tspub/"))
  (set-register ?a (cons 'file "~/src/gitlab/tspub/etc/agnostic"))
  (set-register ?e (cons 'file "~/src/gitlab/tspub/etc/emacs/"))
  (set-register ?l (cons 'file "~/src/gitlab/tspub/etc/emacs/site-lisp"))
  (set-register ?o (cons 'file "~/src/gitlab/tsprv/org/"))
  (set-register ?n (cons 'file "~/src/gitlab/tsprv/org/work/notes.org"))
  (set-register ?t (cons 'file "~/src/gitlab/tsprv/org/work/todo.org"))
  (set-register ?w (cons 'file "~/src/oe-developers/"))
  (set-register ?b (cons 'file "~/src/oe-developers/be/"))
  (set-register ?d (cons 'file "~/src/oe-developers/be/devops"))

  (global-set-key (kbd "C-x j") 'jump-to-register)
  (define-key ctl-x-4-map "j" 'my/jump-to-register-other-window)
#+end_src
** Removes
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/remove-from-buffer (string)
    "Remove all occurences of STRING from the whole buffer."
    (interactive "sString to remove: ")
    (save-match-data
      (save-excursion
        (let ((count 0))
          (goto-char (point-min))
          (while (re-search-forward string (point-max) t)
            (setq count (+ count 1))
            (replace-match "" nil nil))
          (message (format "%d %s removed from buffer." count string))))))

  ;;;###autoload
  (defun my/remove-character-number (number)
    "Remove all occurences of a control character NUMBER.
  Excluding ^I (tabs) and ^J (newline)."
    (if (and (>= number 0) (<= number 31)
             (not (= number 9)) (not (= number 10)))
        (let ((character (string number)))
          (my/remove-from-buffer character))))

  ;;;###autoload
  (defun my/remove-all-ctrl-characters ()
    "Remove all occurences of all control characters.
  Excluding ^I (tabs) and ^J (newlines)."
    (interactive)
    (mapcar (lambda (n)
              (my/remove-character-number n))
            (number-sequence 0 31)))

  ;;;###autoload
  (defun my/remove-ctrl-m ()
    "Remove all ^M occurrences from EOL in a buffer."
    (interactive)
    (my/remove-from-buffer "$"))

  (global-set-key (kbd "C-c k") 'my/remove-from-buffer)
#+end_src
** Settings
#+begin_src emacs-lisp
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
  (setq auto-save-timeout 5)

  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq backup-by-copying t) ;; copy files, don't rename them.
  (setq delete-old-versions t)
  (setq kept-new-versions 12)
  (setq kept-old-versions 12)

  (setq ring-bell-function 'ignore)
  (setq visible-bell 1)

  (setq select-enable-clipboard t)
  (setq select-enable-primary t)
  (setq x-select-enable-clipboard-manager nil)
  (setq save-interprogram-paste-before-kill t)

  (setq display-line-numbers 'relative)

  (setq doc-view-continuous t)
  (setq doc-view-resolution 300)

  (global-subword-mode 1) ;; move by camel case, etc
  (global-auto-revert-mode 1) ;; reload if file changed on disk
  (pending-delete-mode 1) ;; remove selected region if typing

  (setq-default fill-column 79)
  (set-default 'truncate-lines t)
  (add-hook 'text-mode-hook 'auto-fill-mode)

  (setq backward-delete-char-untabify-method 'all)
  (setq create-lockfiles nil) ;; prevent creation of .#myfile.ext
  (setq require-final-newline t) ;; useful for crontab
  (setq set-mark-command-repeat-pop t) ;; repeating C-SPC after popping, pops it

  (with-eval-after-load 'electric
    (electric-indent-mode)
    (electric-pair-mode)
    (show-paren-mode 1)
    (message "Lazy loaded electric :-)"))

  (setq epa-file-cache-passphrase-for-symmetric-encryption t)
  (setf epg-pinentry-mode 'loopback)

  (global-highlight-changes-mode)
  (setq highlight-changes-visibility-initial-state nil)

  (setq history-length t)
  (setq history-delete-duplicates t)
  (setq bookmark-save-flag 1) ;; always save bookmarks to file
  (save-place-mode 1)
  (setq save-place-file (concat user-emacs-directory "saveplace.el"))

  (setq load-prefer-newer t) ;; if init.elc is older, use newer init.el

  (setq custom-file (make-temp-file "emacs-custom"))
  (setq disabled-command-function nil) ;; enable all "advanced" features
  (setq message-log-max 10000)
  (setq apropos-do-all t) ;; doesn't seem to be documented anywhere..

  (setq mouse-yank-at-point t)

  (setq scroll-step 4)
  (setq scroll-margin 6)
  (setq scroll-conservatively 8)
  (setq scroll-preserve-screen-position t)

  (defun display-startup-echo-area-message ()
    "Redefine this function to be more useful."
    (message "Started in %s. Hacks & Glory await! :-)" (emacs-init-time)))
  (setq inhibit-startup-screen t)
  (setq initial-scratch-message nil)
  (setq initial-major-mode 'fundamental-mode)

  (with-eval-after-load 'tramp
    (setq tramp-backup-directory-alist backup-directory-alist)
    (setq tramp-default-method "ssh")
    (setf tramp-persistency-file-name (concat temporary-file-directory "tramp-" (user-login-name)))
    (message "Lazy loaded tramp :-)"))

  ;; (setq password-cache t) ; enable password caching
  ;; (setq password-cache-expiry 3600) ; for one hour (time in secs)

  ;; http://www.dr-qubit.org/Lost_undo-tree_history.html
  (setq undo-limit 80000000)
  (setq undo-strong-limit 90000000)

  (setq user-full-name "Toby Slight")
  (setq user-mail-address "tslight@pm.me")

  (with-eval-after-load 'vc
    (setq vc-follow-symlinks t)
    (setq vc-make-backup-files t)
    (setq version-control t)
    (message "Lazy loaded vc :-)"))

  (when (fboundp 'winner-mode) (winner-mode 1))
  (setq split-width-threshold 160)
  (setq split-height-threshold 80)

  (fset 'yes-or-no-p 'y-or-n-p) ;; never have to type full word
  (setq confirm-kill-emacs 'y-or-n-p)
#+end_src
** Shell script
#+begin_src emacs-lisp
  (with-eval-after-load 'sh-script
    (add-hook 'shell-script-mode-hook 'hl-line-mode)
    (add-hook 'sh-script-hook 'display-line-numbers-mode)
    (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
    (add-to-list 'auto-mode-alist '("\\.sh\\'" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\.bash.*\\'" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\.zsh.*\\'" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\bashrc\\'" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\kshrc\\'" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\profile\\'" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\zshenv\\'" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\zprompt\\'" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\zshrc\\'" . shell-script-mode))
    (add-to-list 'auto-mode-alist '("\\prompt_.*_setup\\'" . shell-script-mode))
    (add-to-list 'interpreter-mode-alist '("bash" . shell-script-mode))
    (add-to-list 'interpreter-mode-alist '("ksh" . shell-script-mode))
    (add-to-list 'interpreter-mode-alist '("sh" . shell-script-mode))
    (add-to-list 'interpreter-mode-alist '("zsh" . shell-script-mode))
    (message "Lazy loaded shell-script-mode :-)"))
#+end_src
** Smart
#+begin_src emacs-lisp
  ;;;###autoload
  (defun smart/fill-or-unfill ()
    "Like `fill-paragraph', but unfill if used twice."
    (interactive)
    (let ((fill-column
           (if (eq last-command 'smart/fill-or-unfill)
               (progn (setq this-command nil)
                      (point-max))
             fill-column)))
      (call-interactively #'fill-paragraph)))

  ;;;###autoload
  (defun smart/narrow-or-widen-dwim (p)
    "If the buffer is narrowed, it widens, otherwise, it narrows intelligently.

  Intelligently means: region, org-src-block, org-subtree, or
  defun, whichever applies first.

  Narrowing to org-src-block actually calls `org-edit-src-code'.
  With prefix P, don't widen, just narrow even if buffer is already
  narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing command.
           ;; Remove this first conditional if you don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((org-at-block-p)
                  (org-narrow-to-block))
                 (t (org-narrow-to-subtree))))
          (t (narrow-to-defun))))

  ;;;###autoload
  (defun smart/move-beginning-of-line ()
    "Move point back to indentation.

  If there is any non blank characters to the left of the cursor.
  Otherwise point moves to beginning of line."
    (interactive)
    (if (= (point) (save-excursion (back-to-indentation) (point)))
        (beginning-of-line)
      (back-to-indentation)))

  ;;;###autoload
  (defun smart/kill-ring-save ()
    "Copy current line or text selection to kill ring.

  When `universal-argument' is called first, copy whole buffer (but
  respect `narrow-to-region')."
    (interactive)
    (let (p1 p2)
      (if (null current-prefix-arg)
          (progn (if (use-region-p)
                     (progn (setq p1 (region-beginning))
                            (setq p2 (region-end)))
                   (progn (setq p1 (line-beginning-position))
                          (setq p2 (line-end-position)))))
        (progn (setq p1 (point-min))
               (setq p2 (point-max))))
      (kill-ring-save p1 p2)))

  ;;;###autoload
  (defun smart/kill-region ()
    "Cut current line, or text selection to kill ring.

  When `universal-argument' is called first, cut whole buffer (but
  respect `narrow-to-region')."
    (interactive)
    (let (p1 p2)
      (if (null current-prefix-arg)
          (progn (if (use-region-p)
                     (progn (setq p1 (region-beginning))
                            (setq p2 (region-end)))
                   (progn (setq p1 (line-beginning-position))
                          (setq p2 (line-beginning-position 2)))))
        (progn (setq p1 (point-min))
               (setq p2 (point-max))))
      (kill-region p1 p2)))

  (global-set-key [remap fill-paragraph] 'smart/fill-or-unfill)
  (global-set-key [remap move-beginning-of-line] 'smart/move-beginning-of-line)
  (global-set-key [remap kill-ring-save] 'smart/kill-ring-save)
  (global-set-key [remap kill-region] 'smart/kill-region)

  (define-key ctl-x-map "n" 'smart/narrow-or-widen-dwim)
#+end_src
** Style
#+begin_src emacs-lisp
  (setq c-default-style "bsd")
  (setq c-basic-offset 4)
  (setq css-indent-offset 2)
  (setq js-indent-level 2)

  ;; If indent-tabs-mode is t, it means it may use tab, resulting mixed space and
  ;; tab
  (setq-default indent-tabs-mode nil)

  ;; make tab key always call a indent command.
  ;; (setq-default tab-always-indent t)

  ;; make tab key call indent command or insert tab character, depending on cursor position
  ;; (setq-default tab-always-indent nil)
  (with-eval-after-load 'python
    (setq python-fill-docstring-style 'django)
    (message "Lazy loaded python :-)"))

  ;; make tab key do indent first then completion.
  (setq-default tab-always-indent 'complete)
#+end_src
** Term
#+begin_src emacs-lisp
  (with-eval-after-load 'term
    ;; get unicode characters in ansi-term - https://stackoverflow.com/a/7442266
    (defadvice ansi-term (after advise-ansi-term-coding-system)
      "Get unicode characters in `ansi-term'."
      (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
    (ad-activate 'ansi-term)

    (defadvice term-handle-exit (after term-kill-buffer-on-exit activate)
      "Kill term when shell exits."
      (kill-buffer))

    (setq term-buffer-maximum-size 200000)
    (message "Lazy loaded term :-)"))

  ;;;###autoload
  (defun my/switch-to-ansi-term ()
    "Open an `ansi-term' if it doesn't already exist.
  Otherwise switch to current one."
    (interactive)
    (if (get-buffer "*ansi-term*")
        (switch-to-buffer "*ansi-term*")
      (ansi-term (getenv "SHELL"))))

  ;;;###autoload
  (defun my/switch-to-ansi-term-other-window()
    "Does what it states on the tin!"
    (interactive)
    (split-window-sensibly)
    (other-window 1)
    (my/switch-to-ansi-term))

  ;;;###autoload
  (defun my/ansi-term ()
    "Opens shell from $SHELL environmental variable in `ansi-term'."
    (interactive)
    (ansi-term (getenv "SHELL")))

  ;;;###autoload
  (defun my/ansi-term-other-window ()
    "Opens default $SHELL `ansi-term' in another window."
    (interactive)
    (split-window-sensibly)
    (other-window 1)
    (my/ansi-term))

  (autoload 'term "term" nil t)
  (autoload 'ansi-term "term" nil t)
  (global-set-key (kbd "C-c t") 'my/switch-to-ansi-term)
  (global-set-key (kbd "C-c 4 t") 'my/switch-to-ansi-term-other-window)
  (global-set-key (kbd "C-c C-t") 'my/ansi-term)
  (global-set-key (kbd "C-c 4 C-t") 'my/ansi-term-other-window)

  (add-hook 'term-exec (lambda () (set-process-coding-system 'utf-8-unix 'utf-8-unix)))
#+end_src
** Theme
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/after-make-frame (frame)
    "Add custom settings after making the FRAME."
    (select-frame frame)
    (if (display-graphic-p)
        (progn
          (when (eq system-type 'windows-nt)
            (set-frame-font "Cascadia Mono 10" nil t))
          (when (eq system-type 'darwin)
            (set-frame-font "Monaco 10" nil t))
          (when (or (eq system-type 'gnu/linux)
                    (eq system-type 'berkeley-unix))
            (set-frame-font "Monospace 11" nil t))
          (load-theme 'wombat))
      (progn
        (load-theme 'manoj-dark)
        (xterm-mouse-mode 1)
        (mouse-avoidance-mode 'banish)
        ;; (setq linum-format "%d ")
        (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
        (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
        (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
        (global-set-key [mouse-4] '(lambda () (interactive) (scroll-down 1)))
        (global-set-key [mouse-5] '(lambda () (interactive) (scroll-up 1))))))

  (if (daemonp)
      (add-hook 'after-make-frame-functions #'my/after-make-frame(selected-frame))
    (my/after-make-frame(selected-frame)))

  ;;;###autoload
  (defun my/disable-themes ()
    "Disable all custom themes in one fail swoop."
    (interactive)
    (mapc #'disable-theme custom-enabled-themes))

  (global-set-key (kbd "C-c M-t C-t") 'my/disable-themes)

  (setq default-frame-alist
        '((fullscreen . maximized) (vertical-scroll-bars . nil)))

  ;; mode line stuff
  ;; (setq display-time-format "%H:%M %d/%m")
  ;; (setq display-time-default-load-average 'nil)
  (column-number-mode t)
  ;; (display-time-mode t)
  ;; (display-battery-mode t)
  ;; (size-indication-mode t)

  (setq prettify-symbols-unprettify-at-point 'right-edge)
  (global-prettify-symbols-mode 1)

  (defadvice load-theme (before theme-dont-propagate activate)
    "Disable theme before loading new one."
    (mapc #'disable-theme custom-enabled-themes))
#+end_src
** Whitespace
#+begin_src emacs-lisp
  (with-eval-after-load 'whitespace
    (setq whitespace-line-column 120)
    (setq whitespace-style '(face
                             tabs
                             spaces
                             trailing
                             lines
                             space-before-tab::space
                             newline
                             indentation::space
                             empty
                             space-after-tab::space
                             space-mark
                             tab-mark
                             newline-mark)
          whitespace-face 'whitespace-trailing)
    (global-set-key (kbd "C-c M-w") 'whitespace-mode)
    (message "Lazy loaded whitespace :-)"))

  (add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src
** Windows
#+begin_src emacs-lisp
  ;;;###autoload
  (defun my/three-way-split ()
    "Split the screen three ways."
    (interactive)
    (split-window-horizontally)
    (other-window 1 nil)
    (switch-to-next-buffer)
    (split-window-horizontally)
    (other-window 1 nil)
    (switch-to-next-buffer)
    (balance-windows))

  ;;;###autoload
  (defun my/kill-buffer-other-window ()
    "Kill the buffer in the last used window."
    (interactive)
    ;; Window selection is used because point goes to a different window if more
    ;; than 2 windows are present
    (let ((current-window (selected-window))
          (other-window (get-mru-window t t t)))
      (select-window other-window)
      (kill-this-buffer)
      (select-window current-window)))

  ;;;###autoload
  (defun my/last-window ()
    "Switch back and forth between two windows easily."
    (interactive)
    (let ((win (get-mru-window t t t)))
      (unless win (error "Last window not found"))
      (let ((frame (window-frame win)))
        (raise-frame frame)
        (select-frame frame)
        (select-window win))))

  ;;;###autoload
  (defun my/open-buffer-other-window (buffer)
    "Open a BUFFER in another window without switching to it."
    (interactive "BBuffer: ")
    (switch-to-buffer-other-window buffer)
    (other-window -1))

  ;;;###autoload
  (defun my/prev-window ()
    "Go the previously used window, excluding other frames."
    (interactive)
    (other-window -1))

  ;;;###autoload
  (defun my/top-of-window ()
    "Shift current line to the top of the window."
    (interactive)
    (set-window-start (selected-window) (point)))

  ;;;###autoload
  (defun my/bottom-of-window ()
    "Shift current line to the bottom of the window."
    (interactive)
    (my/top-of-window)
    (scroll-down (- (window-height) 3)))

  ;;;###autoload
  (defun my/scroll-line-up (n)
    "Scroll line up N lines.  Like Ctrl-e in Vim."
    (interactive "p")
    (scroll-up n))

  ;;;###autoload
  (defun my/scroll-line-down (n)
    "Scroll line down N lines.  Ctrl-y in Vim."
    (interactive "p")
    (scroll-down n))

  ;;;###autoload
  (defun my/hsplit-last-buffer (prefix)
    "Split the window vertically and display the previous buffer.
  With PREFIX stay in current buffer."
    (interactive "p")
    (split-window-vertically)
    (other-window 1 nil)
    (if (= prefix 1)
        (switch-to-next-buffer)))

  ;;;###autoload
  (defun my/vsplit-last-buffer (prefix)
    "Split the window horizontally and display the previous buffer.
  With PREFIX stay in current buffer."
    (interactive "p")
    (split-window-horizontally)
    (other-window 1 nil)
    (if (= prefix 1) (switch-to-next-buffer)))

  ;;;###autoload
  (defun my/toggle-split ()
    "Switch window split from horizontally to vertically.

  Or vice versa.  Change right window to bottom, or change bottom
  window to right."
    (interactive)
    (let ((done))
      (dolist (dirs '((right . down) (down . right)))
        (unless done
          (let* ((win (selected-window))
                 (nextdir (car dirs))
                 (neighbour-dir (cdr dirs))
                 (next-win (windmove-find-other-window nextdir win))
                 (neighbour1 (windmove-find-other-window neighbour-dir win))
                 (neighbour2 (if next-win (with-selected-window next-win
                                            (windmove-find-other-window neighbour-dir next-win)))))
            ;;(message "win: %s\nnext-win: %s\nneighbour1: %s\nneighbour2:%s" win next-win neighbour1 neighbour2)
            (setq done (and (eq neighbour1 neighbour2)
                            (not (eq (minibuffer-window) next-win))))
            (if done
                (let* ((other-buf (window-buffer next-win)))
                  (delete-window next-win)
                  (if (eq nextdir 'right)
                      (split-window-vertically)
                    (split-window-horizontally))
                  (set-window-buffer (windmove-find-other-window neighbour-dir) other-buf))))))))

  ;;;###autoload
  (defun my/transpose-windows (arg)
    "Transpose windows.  Use prefix ARG to transpose in the other direction."
    (interactive "P")
    (if (not (> (count-windows) 1))
        (message "You can't rotate a single window!")
      (let* ((rotate-times (prefix-numeric-value arg))
             (direction (if (or (< rotate-times 0) (equal arg '(4)))
                            'reverse 'identity)))
        (dotimes (_ (abs rotate-times))
          (dotimes (i (- (count-windows) 1))
            (let* ((w1 (elt (funcall direction (window-list)) i))
                   (w2 (elt (funcall direction (window-list)) (+ i 1)))
                   (b1 (window-buffer w1))
                   (b2 (window-buffer w2))
                   (s1 (window-start w1))
                   (s2 (window-start w2))
                   (p1 (window-point w1))
                   (p2 (window-point w2)))
              (set-window-buffer-start-and-point w1 b2 s2 p2)
              (set-window-buffer-start-and-point w2 b1 s1 p1)))))))

  (autoload 'windmove-left "windmove" nil t)
  (global-set-key (kbd "C-c w b") 'windmove-left)
  (autoload 'windmove-right "windmove" nil t)
  (global-set-key (kbd "C-c w f") 'windmove-right)
  (autoload 'windmove-up "windmove" nil t)
  (global-set-key (kbd "C-c w p") 'windmove-up)
  (autoload 'windmove-down "windmove" nil t)
  (global-set-key (kbd "C-c w n") 'windmove-down)
  (with-eval-after-load 'windmove
    (setq windmove-wrap-around t)
    (message "Lazy loaded windmove :-)"))

  (setq auto-window-vscroll nil)

  (global-set-key (kbd "C-x O") 'my/prev-window)
  (global-set-key (kbd "C-c 3") 'my/vsplit-last-buffer)
  (global-set-key (kbd "C-c 2") 'my/hsplit-last-buffer)
  (global-set-key (kbd "C-M-<") 'my/top-of-window)
  (global-set-key (kbd "C-M->") 'my/bottom-of-window)
  (global-set-key (kbd "M-p") 'my/scroll-line-up)
  (global-set-key (kbd "M-n") 'my/scroll-line-down)

  (global-set-key (kbd "C-c v") 'scroll-other-window-down)
  (global-set-key (kbd "C-c w u") 'winner-undo)
  (global-set-key (kbd "C-c w r") 'winner-redo)

  (define-key ctl-x-4-map "k" 'my/kill-buffer-other-window)
  (define-key ctl-x-4-map "o" 'my/open-buffer-other-window)
  (define-key ctl-x-4-map "s" 'my/toggle-split)
  (define-key ctl-x-4-map "t" 'my/transpose-windows)
#+end_src
* Third party package configuration

I like to split up my "vanilla" Emacs configuration and custom functions from
the customisations provided by third party libraries that have been installed
using ~package.el~ and ~use-package~.

If you want to go for a more vanilla setup, just prefix the ~COMMENT~ keyword
to the tile above, and re-tangle the file.

This way it makes it very easy to run a semi-stock Emacs without ~package.el~
or any third party libraries, but still have some saner defaults and some extra
functionality.

I'm using John Wiegley's awesome [[https://github.com/jwiegley/use-package][use-package]] to pull in and configure any third
party packages from [[https://melpa.org/][MELPA]].

** Setup package.el and use-package

#+begin_src emacs-lisp
  (require 'package)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-enable-imenu-support t
        ;; use-package-hook-name-suffix nil
        use-package-always-ensure t
        use-package-verbose t)
  (require 'use-package)
#+end_src

** Ansible

#+begin_src emacs-lisp
  (use-package ansible :defer
    :hook (yaml-mode . ansible))
#+end_src

#+begin_src emacs-lisp
  (use-package ansible-doc :defer
    :hook (yaml-mode . ansible-doc-mode))
#+end_src

** Async

#+begin_src emacs-lisp
  (use-package async :defer
    :config (async-bytecomp-package-mode 1)
    :hook (dired-mode-hook . dired-async-mode))
#+end_src

** Blacken

#+begin_src emacs-lisp
  (use-package blacken :defer
    :hook (python-mode . blacken-mode))
#+end_src

** Default text scaling

#+begin_src emacs-lisp
  (use-package default-text-scale
    :if window-system
    :bind*
    ("C-M-=" . default-text-scale-increase)
    ("C-M--" . default-text-scale-decrease)
    ("C-M-0" . default-text-scale-reset))
#+end_src

** Diminish

#+begin_src emacs-lisp
  (use-package diminish :defer 2
    :diminish abbrev-mode
    :diminish auto-fill-function ;; wtf?!
    :diminish eldoc-mode
    :diminish hs-minor-mode
    :diminish highlight-changes-mode
    :diminish my/key-mode
    :diminish org-indent-mode
    :diminish org-src-mode
    :diminish subword-mode
    :hook
    (org-indent-mode . (lambda () (diminish 'org-indent-mode)))
    (hs-minor-mode . (lambda () (diminish 'hs-minor-mode))))
#+end_src

** Docker

#+begin_src emacs-lisp
  (use-package docker
    :bind ("C-c C-d" . docker))

  (use-package dockerfile-mode :defer)
#+end_src

** Exec path from shell

#+begin_src emacs-lisp
  (use-package exec-path-from-shell :defer 10
    :if (not (eq system-type 'windows-nt))
    :commands exec-path-from-shell-initialize
    :init
    (setq exec-path-from-shell-check-startup-files 'nil)
    :config
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-env "PYTHONPATH"))
#+end_src

** Flycheck

#+begin_src emacs-lisp
  (use-package flycheck :defer
    :diminish flycheck-mode
    :hook (prog-mode . flycheck-mode)
    :config (flycheck-add-mode 'javascript-eslint 'web-mode))
#+end_src

** Git Timemachine

#+begin_src emacs-lisp
  (use-package git-timemachine :defer)
#+end_src

** Gitlab CI

#+begin_src emacs-lisp
  (use-package gitlab-ci-mode :defer
    :mode
    "\\.gitlab-ci.yaml\\'"
    "\\.gitlab-ci.yml\\'"
    :hook
    (yaml-mode . hs-minor-mode))
#+end_src

** Go mode

#+begin_src emacs-lisp
  (use-package go-mode :defer
    :config
    (defun my/go-indent ()
      (setq indent-tabs-mode 1)
      (setq tab-width 2))
    :hook (go-mode . my/go-indent))
#+end_src

** Hungry delete

#+begin_src emacs-lisp
  (use-package hungry-delete :defer 6
    :diminish hungry-delete-mode
    :config (global-hungry-delete-mode))
#+end_src

** Ibuffer VC

#+begin_src emacs-lisp
  (use-package ibuffer-vc :defer
    :config
    (defun my/ibuffer-vc-setup ()
      (ibuffer-vc-set-filter-groups-by-vc-root)
      (unless (eq ibuffer-sorting-mode 'alphabetic)
        (ibuffer-do-sort-by-alphabetic)))
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 18 18 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                  vc-relative-file)))
    :hook
    (ibuffer . my/ibuffer-vc-setup))
#+end_src

** JS2 mode

#+begin_src emacs-lisp
  (use-package js2-mode :defer
    :hook
    (js-mode . js2-minor-mode)
    (js2-mode . js2-imenu-extras-mode)
    :mode
    "\\.js\\'")

  (use-package js2-refactor :defer
    :hook (js2-mode . js2-refactor-mode)
    :bind (:map js2-mode-map
                ("C-k" . js2r-kill))
    :config (js2r-add-keybindings-with-prefix "C-c C-j"))
#+end_src

** JSON

#+begin_src emacs-lisp
  (use-package json-mode :defer
    :config
    (defun my/json-mode-setup ()
      (json-mode)
      (json-pretty-print (point-min) (point-max))
      (goto-char (point-min))
      (set-buffer-modified-p nil))
    (add-to-list 'auto-mode-alist
                 '("\\.json\\'" . 'my/json-mode-setup)))

  (use-package json-navigator :defer)
#+end_src

** Lazygit

#+begin_src emacs-lisp
  (use-package lazygitlab :ensure nil
    :if (file-directory-p (expand-file-name "~/src/gitlab/tspub/lisp/lazygit"))
    :load-path (lambda () (expand-file-name "~/src/gitlab/tspub/lisp/lazygit"))
    :bind
    ("C-c g l a" . lazygitlab-clone-or-pull-all)
    ("C-c g l c" . lazygitlab-clone-or-pull-project)
    ("C-c g l g" . lazygitlab-clone-or-pull-group)
    ("C-c g l r" . lazygitlab-retriever)
    :config
    (setq lazygit-token-file (expand-file-name "~/.lazygit.el"))
    (defalias 'gl/api 'lazygitlab-retriever)
    (defalias 'gl/all 'lazygitlab-clone-or-pull-all)
    (defalias 'gl/grp 'lazygitlab-clone-or-pull-group)
    (defalias 'gl/repo 'lazygitlab-clone-or-pull-project))
#+end_src

#+begin_src emacs-lisp
  (use-package lazygithub :ensure nil
    :if (file-directory-p (expand-file-name "~/src/gitlab/tspub/lisp/lazygit"))
    :load-path (lambda () (expand-file-name "~/src/gitlab/tspub/lisp/lazygit"))
    :bind
    ("C-c g h a" . lazygithub-clone-or-pull-all)
    ("C-c g h c" . lazygithub-clone-or-pull-repo)
    ("C-c g h r" . lazygithub-retriever)
    :config
    (setq lazygit-token-file (expand-file-name "~/.lazygit.el"))
    (defalias 'gh/api 'lazygithub-retriever)
    (defalias 'gh/all 'lazygithub-clone-or-pull-all)
    (defalias 'gh/repo 'lazygithub-clone-or-pull-repo))
#+end_src

** Magit

#+begin_src emacs-lisp
  (use-package magit
    :bind*
    ("C-x g" . magit-status)
    :config
    (when (eq system-type 'windows-nt)
      (if (file-readable-p "C:/Program Files/Git/bin/git.exe")
          (setq magit-git-executable "C:/Program Files/Git/bin/git.exe"))
      (when (file-directory-p "C:/Program Files/Git/bin")
        (setq exec-path (add-to-list 'exec-path "C:/Program Files/Git/bin"))
        (setenv "PATH" (concat "C:\\Program Files\\Git\\bin;" (getenv "PATH")))))
    (setq magit-clone-set-remote.pushDefault t)
    (setq magit-completing-read-function 'magit-builtin-completing-read))
#+end_src

#+begin_src emacs-lisp
  (use-package magit-repos :ensure nil
    :bind* ("C-x C-g" . magit-list-repositories)
    :config
    (setq magit-repository-directories `(("~/" . 0)
                                         ("~/src/gitlab" . 10)))
    (setq magit-repolist-columns
          '(("Name" 25 magit-repolist-column-ident)
            ;; ("Version" 25 magit-repolist-column-version)
            ("Pull" 5 magit-repolist-column-unpulled-from-upstream)
            ("Push" 5 magit-repolist-column-unpushed-to-upstream)
            ("Commit" 8 magit-repolist-column-flag t)
            ("Path" 99 magit-repolist-column-path))))
#+end_src

** Markdown

#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . gfm-mode)
           ("\\.markdown\\'" . gfm-mode))
    :init (setq markdown-command "multimarkdown"))
#+end_src

** Node JS

#+begin_src emacs-lisp
  (use-package nodejs-repl :defer
    :bind
    (:map js2-mode-map
          ("C-x C-e" . nodejs-repl-send-last-expression)
          ("C-c C-j" . nodejs-repl-send-line)
          ("C-c SPC" . nodejs-repl-send-region)
          ("C-c C-b" . nodejs-repl-send-buffer)
          ("C-c C-f" . nodejs-repl-load-file)
          ("C-c C-z" . nodejs-repl-switch-to-repl)))
#+end_src

** Org
*** Org Bullets

#+begin_src emacs-lisp
  (use-package org-bullets :defer
    :hook (org-mode . org-bullets-mode))
#+end_src

*** HTMLize

#+begin_src emacs-lisp
  (use-package htmlize :defer)
#+end_src

*** Toc Org

#+begin_src emacs-lisp
  (use-package toc-org :defer
    :hook (org-mode . toc-org-enable))
#+end_src

*** PDF Tools
#+begin_src emacs-lisp
  (use-package pdf-tools :defer)
#+end_src

** Powershell

#+begin_src emacs-lisp
  (use-package powershell
    :mode (("\\.ps1\\'" . powershell-mode)))
#+end_src

** Powerline

#+begin_src emacs-lisp
  (use-package powerline :defer 4
    :config
    (if window-system ; use-package if doesn't work for emacsclient
        (powerline-default-theme)))
#+end_src

** Projectile

#+begin_src emacs-lisp
  (use-package projectile :diminish projectile-mode
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :config
    (projectile-mode)
    ;; (setq projectile-completion-system 'ivy)
    (when (require 'magit nil t)
      (mapc #'projectile-add-known-project
            (mapcar #'file-name-as-directory (magit-list-repos)))
      ;; Optionally write to persistent `projectile-known-projects-file'
      (projectile-save-known-projects)))
#+end_src

** RESTClient

#+begin_src emacs-lisp
  (use-package restclient :defer)
#+end_src

** systemd

#+begin_src emacs-lisp
  (use-package systemd :defer)
#+end_src

** Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode :defer)
#+end_src

** Web Mode

#+begin_src emacs-lisp
  (use-package web-mode
    :mode
    "\\.phtml\\'"
    "\\.tpl\\.php\\'"
    "\\.[agj]sp\\'"
    "\\.as[cp]x\\'"
    "\\.erb\\'"
    "\\.mustache\\'"
    "\\.djhtml\\'"
    "\\.html\\.twig\\'"
    "\\.html?\\'"
    "\\.php?\\'"
    "\\.css?\\'"
    :hook
    (web-mode . js2-minor-mode)
    :config
    (setq web-mode-content-type "jsx")
    (setq web-mode-enable-auto-quoting nil)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-attr-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-enable-auto-pairing t)
    (setq web-mode-enable-css-colorization t)
    (setq web-mode-enable-block-face t)
    (setq web-mode-enable-part-face t)
    (setq web-mode-enable-comment-keywords t)
    (add-to-list 'web-mode-indentation-params '("lineup-args" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-calls" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-concats" . nil))
    (add-to-list 'web-mode-indentation-params '("lineup-ternary" . nil)))
#+end_src

** Writeable Grep

#+begin_src emacs-lisp
  (use-package wgrep :defer :commands wgrep
    :bind (:map grep-mode-map
                ("e" . wgrep-change-to-wgrep-mode)
                ("C-x C-q" . wgrep-change-to-wgrep-mode)))
#+end_src

** Which Key

#+begin_src emacs-lisp
  (use-package which-key :defer 5
    :diminish which-key-mode
    :config
    (which-key-mode))
#+end_src

** YAML

#+begin_src emacs-lisp
  (use-package yaml-mode :defer)
#+end_src

** Yasnippet

#+begin_src emacs-lisp

  (use-package yasnippet :defer
    :diminish yas-minor-mode
    :hook (prog-mode . yas-minor-mode))
#+end_src

*** Snippets

#+begin_src emacs-lisp

  (use-package yasnippet-snippets :defer)
#+end_src

*** Classic snippets
#+begin_src emacs-lisp
  (use-package yasnippet-classic-snippets :defer)
#+end_src

*** Custom Yasnippet snippets

**** Emacs Lisp snippets

***** Standard elisp boilerplate

#+begin_src emacs-lisp :tangle ~/.emacs.d/snippets/emacs-lisp-mode/boilerplate
  # -*- mode: snippet -*-
  # name: boilerplate
  # key: bp
  # --
  ;;; `(file-name-nondirectory (buffer-file-name))` --- ${1:summary} -*- lexical-binding: t; -*-

  ;;; Commentary:

  ;; ${2:commentary}

  ;; Copyright (C) `(format-time-string "%Y")` `user-full-name`
  ;; Author: `user-full-name` <`user-mail-address`>

  ;;; Code:
  $0
  (provide \'`(file-name-sans-extension (file-name-nondirectory (buffer-file-name)))`)
  ;; Local Variables:
  ;; indent-tabs-mode: nil
  ;; byte-compile-warnings: (not free-vars noruntime)
  ;; End:
  ;;; `(file-name-nondirectory (buffer-file-name))` ends here
#+end_src

***** Package elisp boilerplate

#+begin_src emacs-lisp :tangle ~/.emacs.d/snippets/emacs-lisp-mode/boilerplate-package
  # -*- mode: snippet -*-
  # name: boilerplate-package
  # key: bpp
  # --
  ;;; `(file-name-nondirectory (buffer-file-name))` --- ${1:summary} -*- lexical-binding: t; -*-

  ;;; Commentary:

  ;; ${2:commentary}

  ;; Copyright (C) `(format-time-string "%Y")` `user-full-name`
  ;; Author: `user-full-name` `user-mail-address`
  ;; Version: 0.0.1
  ;; Package-Requires: ${3:depandancies}
  ;; URL: https://github.com/tslight/${4:repo}

  ;;; Code:
  $0
  (provide \'`(file-name-sans-extension (file-name-nondirectory (buffer-file-name)))`)
  ;; Local Variables:
  ;; indent-tabs-mode: nil
  ;; byte-compile-warnings: (not free-vars noruntime)
  ;; End:
  ;;; `(file-name-nondirectory (buffer-file-name))` ends here
#+end_src

* Restore garbage collection

It is important to reset the garbage collection settings eventually. Not doing
so will cause garbage collection freezes during long-term interactive
use. Conversely, a gc-cons-threshold that is too small will cause
stuttering. We use 16mb as our default.

#+begin_src emacs-lisp
  (defun my/default-gc-cons-settings ()
    (setq gc-cons-threshold 16777216 ; 16mb
          gc-cons-percentage 0.1))
  (add-hook 'emacs-startup-hook 'my/default-gc-cons-settings)
#+end_src

* Restore original file-name-handler-alist

Don’t forget to restore file-name-handler-alist, otherwise TRAMP won’t work and
compressed/encrypted files won’t open.

#+begin_src emacs-lisp
  (defun my/restore-default-file-name-handler-alist ()
    (setq file-name-handler-alist my/default-file-name-handler-alist))
  (add-hook 'emacs-startup-hook 'my/restore-default-file-name-handler-alist)
#+end_src
